using System;
using System.Collections;
using System.Runtime.InteropServices;
using Gst.GLib;
using Gst;
using Gst.Interfaces;

namespace Gst.CorePlugins {
#region Autogenerated code
	[GTypeName ("GstTypeFindElement")]
	public sealed class TypeFindElement : Gst.Element {
		public TypeFindElement (IntPtr raw) : base (raw) { }

		[DllImport("libgstreamer-0.10.dll") ]
		static extern IntPtr gst_element_factory_make (IntPtr element, IntPtr name);

		public TypeFindElement (string name) : base (IntPtr.Zero) {
			IntPtr native_name = Gst.GLib.Marshaller.StringToPtrGStrdup (name);
			IntPtr native_element = Gst.GLib.Marshaller.StringToPtrGStrdup ("typefind");
			Raw = gst_element_factory_make (native_element, native_name);
			Gst.GLib.Marshaller.Free (native_name);
			Gst.GLib.Marshaller.Free (native_element);
			if (Raw == IntPtr.Zero)
				throw new Exception ("Failed to instantiate element \"typefind\"");
		}

		public TypeFindElement () : this ((string) null) { }

		public static TypeFindElement Make (string name) {
			return Gst.ElementFactory.Make ("typefind", name) as TypeFindElement;
		}

		public static TypeFindElement Make () { return Make (null); } 

		[Gst.GLib.Property ("name")]
		public string Name {
			get {
				Gst.GLib.Value val = GetProperty ("name");
				string ret = (string) val.Val;
				val.Dispose ();
				return ret;
			}
			set {
				Gst.GLib.Value val = new Gst.GLib.Value (this, "name");
				val.Val = value;
				SetProperty ("name", val);
				val.Dispose ();
			}
		}

		[Gst.GLib.Property ("caps")]
		public Gst.Caps Caps {
			get {
				Gst.GLib.Value val = GetProperty ("caps");
				Gst.Caps ret = (Gst.Caps) val.Val;
				val.Dispose ();
				return ret;
			}
			set {
				Gst.GLib.Value val = new Gst.GLib.Value (this, "caps");
				val.Val = value;
				SetProperty ("caps", val);
				val.Dispose ();
			}
		}

		[Gst.GLib.Property ("minimum")]
		public uint Minimum {
			get {
				Gst.GLib.Value val = GetProperty ("minimum");
				uint ret = (uint) val.Val;
				val.Dispose ();
				return ret;
			}
			set {
				Gst.GLib.Value val = new Gst.GLib.Value (this, "minimum");
				val.Val = value;
				SetProperty ("minimum", val);
				val.Dispose ();
			}
		}

		[Gst.GLib.Property ("maximum")]
		public uint Maximum {
			get {
				Gst.GLib.Value val = GetProperty ("maximum");
				uint ret = (uint) val.Val;
				val.Dispose ();
				return ret;
			}
			set {
				Gst.GLib.Value val = new Gst.GLib.Value (this, "maximum");
				val.Val = value;
				SetProperty ("maximum", val);
				val.Dispose ();
			}
		}

		[Gst.GLib.Property ("force-caps")]
		public Gst.Caps ForceCaps {
			get {
				Gst.GLib.Value val = GetProperty ("force-caps");
				Gst.Caps ret = (Gst.Caps) val.Val;
				val.Dispose ();
				return ret;
			}
			set {
				Gst.GLib.Value val = new Gst.GLib.Value (this, "force-caps");
				val.Val = value;
				SetProperty ("force-caps", val);
				val.Dispose ();
			}
		}


		public delegate void HaveTypeHandler (object o, HaveTypeArgs args);

		public class HaveTypeArgs : Gst.GLib.SignalArgs {
			public uint Probability {
				get {
					return (uint) Args[0];
				}
			}

			public Gst.Caps Caps {
				get {
					return (Gst.Caps) Args[1];
				}
			}

		}

		public event HaveTypeHandler HaveType {
			add {
				DynamicSignal.Connect (this, "have-type", value);
			}

			remove {
				DynamicSignal.Disconnect (this, "have-type", value);
			}
		}
#endregion
	}

}
