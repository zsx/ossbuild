diff -Naur generator-upstream/BoxedGen.cs generator/BoxedGen.cs
--- generator-upstream/BoxedGen.cs	2009-01-04 23:29:56.000000000 +0100
+++ generator/BoxedGen.cs	2009-11-25 08:07:47.000000000 +0100
@@ -40,16 +40,16 @@
 
 			StreamWriter sw = gen_info.Writer = gen_info.OpenStream (Name);
 			base.Generate (gen_info);
-			sw.WriteLine ("\t\tpublic static explicit operator GLib.Value (" + QualifiedName + " boxed)");
+			sw.WriteLine ("\t\tpublic static explicit operator Gst.GLib.Value (" + QualifiedName + " boxed)");
 			sw.WriteLine ("\t\t{");
 
-			sw.WriteLine ("\t\t\tGLib.Value val = GLib.Value.Empty;");
+			sw.WriteLine ("\t\t\tGst.GLib.Value val = Gst.GLib.Value.Empty;");
 			sw.WriteLine ("\t\t\tval.Init (" + QualifiedName + ".GType);");
 			sw.WriteLine ("\t\t\tval.Val = boxed;");
 			sw.WriteLine ("\t\t\treturn val;");
 			sw.WriteLine ("\t\t}");
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tpublic static explicit operator " + QualifiedName + " (GLib.Value val)");
+			sw.WriteLine ("\t\tpublic static explicit operator " + QualifiedName + " (Gst.GLib.Value val)");
 			sw.WriteLine ("\t\t{");
 
 			sw.WriteLine ("\t\t\treturn (" + QualifiedName + ") val.Val;");
diff -Naur generator-upstream/ByRefGen.cs generator/ByRefGen.cs
--- generator-upstream/ByRefGen.cs	2008-02-26 17:29:14.000000000 +0100
+++ generator/ByRefGen.cs	2009-11-25 08:07:47.000000000 +0100
@@ -46,7 +46,7 @@
 
 		public string AllocNative (string var_name)
 		{
-			return "GLib.Marshaller.StructureToPtrAlloc (" + var_name + ")";
+			return "Gst.GLib.Marshaller.StructureToPtrAlloc (" + var_name + ")";
 		}
 
 		public override string FromNative (string var_name)
diff -Naur generator-upstream/CallbackGen.cs generator/CallbackGen.cs
--- generator-upstream/CallbackGen.cs	2009-09-03 21:50:53.000000000 +0200
+++ generator/CallbackGen.cs	2009-11-25 08:07:47.000000000 +0100
@@ -140,7 +140,7 @@
 			sw.WriteLine ();
 			sw.WriteLine ("\t\t" + Name + "Native native_cb;");
 			sw.WriteLine ("\t\tIntPtr __data;");
-			sw.WriteLine ("\t\tGLib.DestroyNotify __notify;");
+			sw.WriteLine ("\t\tGst.GLib.DestroyNotify __notify;");
 			sw.WriteLine ();
 			sw.WriteLine ("\t\t~" + Name + "Invoker ()");
 			sw.WriteLine ("\t\t{");
@@ -153,7 +153,7 @@
 			sw.WriteLine ();
 			sw.WriteLine ("\t\tinternal " + Name + "Invoker (" + Name + "Native native_cb, IntPtr data) : this (native_cb, data, null) {}");
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tinternal " + Name + "Invoker (" + Name + "Native native_cb, IntPtr data, GLib.DestroyNotify notify)");
+			sw.WriteLine ("\t\tinternal " + Name + "Invoker (" + Name + "Native native_cb, IntPtr data, Gst.GLib.DestroyNotify notify)");
 			sw.WriteLine ("\t\t{");
 			sw.WriteLine ("\t\t\tthis.native_cb = native_cb;");
 			sw.WriteLine ("\t\t\t__data = data;");
@@ -233,7 +233,7 @@
 			*/
 			bool fatal = (retval.MarshalType != "void" && retval.MarshalType != "bool") || call.HasOutParam;
 			sw.WriteLine ("\t\t\t} catch (Exception e) {");
-			sw.WriteLine ("\t\t\t\tGLib.ExceptionManager.RaiseUnhandledException (e, " + (fatal ? "true" : "false") + ");");
+			sw.WriteLine ("\t\t\t\tGst.GLib.ExceptionManager.RaiseUnhandledException (e, " + (fatal ? "true" : "false") + ");");
 			if (fatal) {
 				sw.WriteLine ("\t\t\t\t// NOTREACHED: Above call does not return.");
 				sw.WriteLine ("\t\t\t\tthrow e;");
diff -Naur generator-upstream/ConstFilenameGen.cs generator/ConstFilenameGen.cs
--- generator-upstream/ConstFilenameGen.cs	2007-09-21 18:37:04.000000000 +0200
+++ generator/ConstFilenameGen.cs	2009-11-25 08:07:47.000000000 +0100
@@ -35,17 +35,17 @@
 		
 		public override string FromNative (string var)
 		{
-			return "GLib.Marshaller.FilenamePtrToString (" + var + ")";
+			return "Gst.GLib.Marshaller.FilenamePtrToString (" + var + ")";
 		}
 
 		public string AllocNative (string managed_var)
 		{
-			return "GLib.Marshaller.StringToFilenamePtr (" + managed_var + ")";
+			return "Gst.GLib.Marshaller.StringToFilenamePtr (" + managed_var + ")";
 		}
 
 		public string ReleaseNative (string native_var)
 		{
-			return "GLib.Marshaller.Free (" + native_var + ")";
+			return "Gst.GLib.Marshaller.Free (" + native_var + ")";
 		}
 	}
 }
diff -Naur generator-upstream/ConstStringGen.cs generator/ConstStringGen.cs
--- generator-upstream/ConstStringGen.cs	2009-08-13 16:46:33.000000000 +0200
+++ generator/ConstStringGen.cs	2009-11-25 08:07:47.000000000 +0100
@@ -37,17 +37,17 @@
 		
 		public override string FromNative (string var)
 		{
-			return "GLib.Marshaller.Utf8PtrToString (" + var + ")";
+			return "Gst.GLib.Marshaller.Utf8PtrToString (" + var + ")";
 		}
 
 		public string AllocNative (string managed_var)
 		{
-			return "GLib.Marshaller.StringToPtrGStrdup (" + managed_var + ")";
+			return "Gst.GLib.Marshaller.StringToPtrGStrdup (" + managed_var + ")";
 		}
 
 		public string ReleaseNative (string native_var)
 		{
-			return "GLib.Marshaller.Free (" + native_var + ")";
+			return "Gst.GLib.Marshaller.Free (" + native_var + ")";
 		}
 	}
 }
diff -Naur generator-upstream/Ctor.cs generator/Ctor.cs
--- generator-upstream/Ctor.cs	2009-09-03 21:50:53.000000000 +0200
+++ generator/Ctor.cs	2009-11-25 08:07:47.000000000 +0100
@@ -32,14 +32,16 @@
 		private bool preferred;
 		private string name;
 		private bool needs_chaining = false;
+		private bool mini_object = false;
 
 		public Ctor (XmlElement elem, ClassBase implementor) : base (elem, implementor) 
 		{
 			if (elem.HasAttribute ("preferred"))
 				preferred = true;
-			if (implementor is ObjectGen)
+			if (implementor is ObjectGen || implementor is MiniObjectGen)
 				needs_chaining = true;
 			name = implementor.Name;
+			mini_object = implementor is MiniObjectGen;
 		}
 
 		public bool Preferred {
@@ -110,9 +112,14 @@
 					sw.WriteLine ("\t\t\tif (GetType () != typeof (" + name + ")) {");
 					
 					if (Parameters.Count == 0) {
-						sw.WriteLine ("\t\t\t\tCreateNativeObject (new string [0], new GLib.Value[0]);");
+						if (mini_object)
+						  sw.WriteLine ("\t\t\t\tCreateNativeObject ();");
+						else
+						  sw.WriteLine ("\t\t\t\tCreateNativeObject (new string [0], new Gst.GLib.Value[0]);");
 						sw.WriteLine ("\t\t\t\treturn;");
 					} else {
+						if (mini_object)
+							throw new Exception ("MiniObject subclasses can't have ctors with parameters");
 						ArrayList names = new ArrayList ();
 						ArrayList values = new ArrayList ();
 						for (int i = 0; i < Parameters.Count; i++) {
@@ -137,13 +144,13 @@
 									indent += "\t";
 								}
 								sw.WriteLine (indent + "names.Add (\"" + names [i] + "\");");
-								sw.WriteLine (indent + "vals.Add (new GLib.Value (" + values[i] + "));");
+								sw.WriteLine (indent + "vals.Add (new Gst.GLib.Value (" + values[i] + "));");
 
 								if (p.Generatable is ClassBase && !(p.Generatable is StructBase))
 									sw.WriteLine ("\t\t\t\t}");
 							}
 
-							sw.WriteLine ("\t\t\t\tCreateNativeObject ((string[])names.ToArray (typeof (string)), (GLib.Value[])vals.ToArray (typeof (GLib.Value)));");
+							sw.WriteLine ("\t\t\t\tCreateNativeObject ((string[])names.ToArray (typeof (string)), (Gst.GLib.Value[])vals.ToArray (typeof (Gst.GLib.Value)));");
 							sw.WriteLine ("\t\t\t\treturn;");
 						} else
 							sw.WriteLine ("\t\t\t\tthrow new InvalidOperationException (\"Can't override this constructor.\");");
diff -Naur generator-upstream/DefaultSignalHandler.cs generator/DefaultSignalHandler.cs
--- generator-upstream/DefaultSignalHandler.cs	2009-04-13 19:44:48.000000000 +0200
+++ generator/DefaultSignalHandler.cs	2009-11-25 08:07:47.000000000 +0100
@@ -68,13 +68,13 @@
 		{
 			GenerateMethodBody (sw, implementor);
 			if (retval.IsVoid)
-				sw.WriteLine ("\t\t\tGLib.Value ret = GLib.Value.Empty;");
+				sw.WriteLine ("\t\t\tGst.GLib.Value ret = Gst.GLib.Value.Empty;");
 			else
-				sw.WriteLine ("\t\t\tGLib.Value ret = new GLib.Value (" + ReturnGType + ");");
+				sw.WriteLine ("\t\t\tGst.GLib.Value ret = new Gst.GLib.Value (" + ReturnGType + ");");
 
-			sw.WriteLine ("\t\t\tGLib.ValueArray inst_and_params = new GLib.ValueArray (" + (parms.Count + 1) + ");");
-			sw.WriteLine ("\t\t\tGLib.Value[] vals = new GLib.Value [" + (parms.Count + 1) + "];");
-			sw.WriteLine ("\t\t\tvals [0] = new GLib.Value (this);");
+			sw.WriteLine ("\t\t\tGst.GLib.ValueArray inst_and_params = new Gst.GLib.ValueArray (" + (parms.Count + 1) + ");");
+			sw.WriteLine ("\t\t\tGst.GLib.Value[] vals = new Gst.GLib.Value [" + (parms.Count + 1) + "];");
+			sw.WriteLine ("\t\t\tvals [0] = new Gst.GLib.Value (this);");
 			sw.WriteLine ("\t\t\tinst_and_params.Append (vals [0]);");
 			string cleanup = "";
 			for (int i = 0; i < parms.Count; i++) {
@@ -82,24 +82,24 @@
 				if (p.PassAs != "") {
 					if (SymbolTable.Table.IsBoxed (p.CType)) {
 						if (p.PassAs == "ref")
-							sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new GLib.Value (" + p.Name + ");");
+							sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new Gst.GLib.Value (" + p.Name + ");");
 						else
-							sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new GLib.Value ((GLib.GType)typeof (" + p.CSType + "));");
+							sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new Gst.GLib.Value ((Gst.GLib.GType)typeof (" + p.CSType + "));");
 						cleanup += "\t\t\t" + p.Name + " = (" + p.CSType + ") vals [" + i + "];\n";
 					} else {
 						if (p.PassAs == "ref")
-							sw.WriteLine ("\t\t\tIntPtr " + p.Name + "_ptr = GLib.Marshaller.StructureToPtrAlloc (" + p.Generatable.CallByName (p.Name) + ");");
+							sw.WriteLine ("\t\t\tIntPtr " + p.Name + "_ptr = Gst.GLib.Marshaller.StructureToPtrAlloc (" + p.Generatable.CallByName (p.Name) + ");");
 						else
 							sw.WriteLine ("\t\t\tIntPtr " + p.Name + "_ptr = Marshal.AllocHGlobal (Marshal.SizeOf (typeof (" + p.MarshalType + ")));");
 
-						sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new GLib.Value (" + p.Name + "_ptr);");
+						sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new Gst.GLib.Value (" + p.Name + "_ptr);");
 						cleanup += "\t\t\t" + p.Name + " = " + p.FromNative ("(" + p.MarshalType + ") Marshal.PtrToStructure (" + p.Name + "_ptr, typeof (" + p.MarshalType + "))") + ";\n";
 						cleanup += "\t\t\tMarshal.FreeHGlobal (" + p.Name + "_ptr);\n";
 					}
 				} else if (p.IsLength && i > 0 && parms [i - 1].IsString)
-					sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new GLib.Value (System.Text.Encoding.UTF8.GetByteCount (" + parms [i-1].Name + "));");
+					sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new Gst.GLib.Value (System.Text.Encoding.UTF8.GetByteCount (" + parms [i-1].Name + "));");
 				else
-					sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new GLib.Value (" + p.Name + ");");
+					sw.WriteLine ("\t\t\tvals [" + (i + 1) + "] = new Gst.GLib.Value (" + p.Name + ");");
 
 				sw.WriteLine ("\t\t\tinst_and_params.Append (vals [" + (i + 1) + "]);");
 			}
@@ -107,7 +107,7 @@
 			sw.WriteLine ("\t\t\tg_signal_chain_from_overridden (inst_and_params.ArrayPtr, ref ret);");
 			if (cleanup != "")
 				sw.WriteLine (cleanup);
-			sw.WriteLine ("\t\t\tforeach (GLib.Value v in vals)");
+			sw.WriteLine ("\t\t\tforeach (Gst.GLib.Value v in vals)");
 			sw.WriteLine ("\t\t\t\tv.Dispose ();");
 			if (!retval.IsVoid) {
 				IGeneratable igen = SymbolTable.Table [retval.CType];
@@ -123,7 +123,9 @@
 				IGeneratable igen = SymbolTable.Table [retval.CType];
 
 				if (igen is ObjectGen)
-					return "GLib.GType.Object";
+					return "Gst.GLib.GType.Object";
+				if (igen is MiniObjectGen)
+					return "Gst.MiniObject.GType";
 				if (igen is BoxedGen)
 					return retval.CSType + ".GType";
 				if (igen is EnumGen)
@@ -131,11 +133,11 @@
 
 				switch (retval.CSType) {
 				case "bool":
-					return "GLib.GType.Boolean";
+					return "Gst.GLib.GType.Boolean";
 				case "string":
-					return "GLib.GType.String";
+					return "Gst.GLib.GType.String";
 				case "int":
-					return "GLib.GType.Int";
+					return "Gst.GLib.GType.Int";
 				default:
 					throw new Exception (retval.CSType);
 				}
diff -Naur generator-upstream/EnumGen.cs generator/EnumGen.cs
--- generator-upstream/EnumGen.cs	2009-09-03 21:50:53.000000000 +0200
+++ generator/EnumGen.cs	2009-11-25 08:07:47.000000000 +0100
@@ -98,7 +98,7 @@
 			if (Elem.GetAttribute("type") == "flags")
 				sw.WriteLine ("\t[Flags]");
 			if (Elem.HasAttribute("gtype"))
-				sw.WriteLine ("\t[GLib.GType (typeof (" + NS + "." + Name + "GType))]");
+				sw.WriteLine ("\t[Gst.GLib.GType (typeof (" + NS + "." + Name + "GType))]");
 
 			string access = IsInternal ? "internal" : "public";
 			sw.WriteLine ("\t" + access + " enum " + Name + enum_type + " {");
@@ -115,9 +115,9 @@
 				sw.WriteLine ("\t\t[DllImport (\"" + LibraryName + "\", CallingConvention = CallingConvention.Cdecl)]");
 				sw.WriteLine ("\t\tstatic extern IntPtr " + Elem.GetAttribute ("gtype") + " ();");
 				sw.WriteLine ();
-				sw.WriteLine ("\t\tpublic static GLib.GType GType {");
+				sw.WriteLine ("\t\tpublic static Gst.GLib.GType GType {");
 				sw.WriteLine ("\t\t\tget {");
-				sw.WriteLine ("\t\t\t\treturn new GLib.GType (" + Elem.GetAttribute ("gtype") + " ());");
+				sw.WriteLine ("\t\t\t\treturn new Gst.GLib.GType (" + Elem.GetAttribute ("gtype") + " ());");
 				sw.WriteLine ("\t\t\t}");
 				sw.WriteLine ("\t\t}");
 				sw.WriteLine ("\t}");
diff -Naur generator-upstream/FieldBase.cs generator/FieldBase.cs
--- generator-upstream/FieldBase.cs	2009-08-13 16:46:33.000000000 +0200
+++ generator/FieldBase.cs	2009-11-25 08:07:47.000000000 +0100
@@ -89,7 +89,7 @@
 		void CheckGlue ()
 		{
 			getterName = setterName = getOffsetName = null;
-			if (Access != "public")
+			if (DefaultAccess != "public" && (!elem.HasAttribute ("access") || (Access != "public" && Access != "protected" && Access != "internal")))
 				return;
 
 			string prefix = (container_type.NS + "Sharp_" + container_type.NS + "_" + container_type.Name).Replace(".", "__").ToLower ();
@@ -154,8 +154,9 @@
 			StreamWriter sw = gen_info.Writer;
 			string modifiers = elem.HasAttribute ("new_flag") ? "new " : "";
 			bool is_struct = table.IsStruct (CType) || table.IsBoxed (CType);
+			string access = elem.HasAttribute ("access") ? elem.GetAttribute ("access") : "public";
 
-			sw.WriteLine (indent + "public " + modifiers + CSType + " " + Name + " {");
+			sw.WriteLine (indent + access + " " + modifiers + CSType + " " + Name + " {");
 
 			if (Getter != null) {
 				sw.Write (indent + "\tget ");
diff -Naur generator-upstream/gapi3-codegen.in generator/gapi3-codegen.in
diff -Naur generator-upstream/GObjectVM.cs generator/GObjectVM.cs
--- generator-upstream/GObjectVM.cs	2009-08-09 01:42:15.000000000 +0200
+++ generator/GObjectVM.cs	2009-11-25 08:07:47.000000000 +0100
@@ -154,17 +154,17 @@
 				sw.WriteLine ("\t\tpublic static " + Name + "Delegate " + Name + "Handler {");
 				sw.WriteLine ("\t\t\tset {");
 				sw.WriteLine ("\t\t\t\t{0}_handler = value;", CName);
-				sw.WriteLine ("\t\t\t\tOverride{0} ((GLib.GType) typeof ({1}), value == null ? null : {0}VMCallback);", Name, container_type.Name);
+				sw.WriteLine ("\t\t\t\tOverride{0} ((Gst.GLib.GType) typeof ({1}), value == null ? null : {0}VMCallback);", Name, container_type.Name);
 				sw.WriteLine ("\t\t\t}");
 				sw.WriteLine ("\t\t}");
 			} else {
-				sw.WriteLine ("\t\tstatic void Override{0} (GLib.GType gtype)", this.Name);
+				sw.WriteLine ("\t\tstatic void Override{0} (Gst.GLib.GType gtype)", this.Name);
 				sw.WriteLine ("\t\t{");
 				sw.WriteLine ("\t\t\tOverride{0} (gtype, {0}VMCallback);", this.Name);
 				sw.WriteLine ("\t\t}");
 			}
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tstatic void Override{0} (GLib.GType gtype, {0}NativeDelegate callback)", this.Name);
+			sw.WriteLine ("\t\tstatic void Override{0} (Gst.GLib.GType gtype, {0}NativeDelegate callback)", this.Name);
 			sw.WriteLine ("\t\t{");
 		}
 
@@ -181,7 +181,7 @@
 
 		protected void GenerateMethodBody (StreamWriter sw, ClassBase implementor)
 		{
-			sw.WriteLine ("\t\t[GLib.DefaultSignalHandler(Type=typeof(" + (implementor != null ? implementor.QualifiedName : container_type.QualifiedName) + "), ConnectionMethod=\"Override" + this.Name +"\")]");
+			sw.WriteLine ("\t\t[Gst.GLib.DefaultSignalHandler(Type=typeof(" + (implementor != null ? implementor.QualifiedName : container_type.QualifiedName) + "), ConnectionMethod=\"Override" + this.Name +"\")]");
 			sw.Write ("\t\t{0} ", this.Protection);
 			if (this.modifiers != "")
 				sw.Write ("{0} ", this.modifiers);
@@ -261,7 +261,7 @@
 					return "FALSE";
 				case "true":
 					return "TRUE";
-				case "GLib.GType.None":
+				case "Gst.GLib.GType.None":
 					return "G_TYPE_NONE";
 				default:
 					return val;
diff -Naur generator-upstream/gst-codegen.diff generator/gst-codegen.diff
diff -Naur generator-upstream/gst-gapi_codegen.exe generator/gst-gapi_codegen.exe
diff -Naur generator-upstream/gst-gapi_codegen.exe.mdb generator/gst-gapi_codegen.exe.mdb
diff -Naur generator-upstream/InterfaceGen.cs generator/InterfaceGen.cs
--- generator-upstream/InterfaceGen.cs	2009-08-19 18:13:17.000000000 +0200
+++ generator/InterfaceGen.cs	2009-11-25 08:07:47.000000000 +0100
@@ -60,7 +60,7 @@
 
 		public override string CallByName (string var, bool owned)
 		{
-			return String.Format ("{0} == null ? IntPtr.Zero : (({0} is GLib.Object) ? ({0} as GLib.Object).{1} : ({0} as {2}Adapter).{1})", var, owned ? "OwnedHandle" : "Handle", QualifiedName);
+			return String.Format ("{0} == null ? IntPtr.Zero : (({0} is Gst.GLib.Object) ? ({0} as Gst.GLib.Object).{1} : ({0} as {2}Adapter).{1})", var, owned ? "OwnedHandle" : "Handle", QualifiedName);
 		}
 
 		public override string FromNative (string var, bool owned)
@@ -91,7 +91,7 @@
 			sw.WriteLine ();
 			sw.WriteLine ("\t\tstatic " + Name + "Adapter ()");
 			sw.WriteLine ("\t\t{");
-			sw.WriteLine ("\t\t\tGLib.GType.Register (_gtype, typeof({0}Adapter));", Name);
+			sw.WriteLine ("\t\t\tGst.GLib.GType.Register (_gtype, typeof({0}Adapter));", Name);
 			foreach (InterfaceVM vm in interface_vms) {
 				if (vm.IsValid)
 					sw.WriteLine ("\t\t\tiface.{0} = new {0}NativeDelegate ({0}_cb);", vm.Name);
@@ -127,22 +127,22 @@
 		void GenerateCtors (StreamWriter sw)
 		{
 			// Native GObjects do not implement the *Implementor interfaces
-			sw.WriteLine ("\t\tGLib.Object implementor;", Name);
+			sw.WriteLine ("\t\tGst.GLib.Object implementor;", Name);
 			sw.WriteLine ();
 
 			if (!IsConsumeOnly) {
 				sw.WriteLine ("\t\tpublic " + Name + "Adapter ()");
 				sw.WriteLine ("\t\t{");
-				sw.WriteLine ("\t\t\tInitHandler = new GLib.GInterfaceInitHandler (Initialize);");
+				sw.WriteLine ("\t\t\tInitHandler = new Gst.GLib.GInterfaceInitHandler (Initialize);");
 				sw.WriteLine ("\t\t}");
 				sw.WriteLine ();
 				sw.WriteLine ("\t\tpublic {0}Adapter ({0}Implementor implementor)", Name);
 				sw.WriteLine ("\t\t{");
 				sw.WriteLine ("\t\t\tif (implementor == null)");
 				sw.WriteLine ("\t\t\t\tthrow new ArgumentNullException (\"implementor\");");
-				sw.WriteLine ("\t\t\telse if (!(implementor is GLib.Object))");
-				sw.WriteLine ("\t\t\t\tthrow new ArgumentException (\"implementor must be a subclass of GLib.Object\");");
-				sw.WriteLine ("\t\t\tthis.implementor = implementor as GLib.Object;");
+				sw.WriteLine ("\t\t\telse if (!(implementor is Gst.GLib.Object))");
+				sw.WriteLine ("\t\t\t\tthrow new ArgumentException (\"implementor must be a subclass of Gst.GLib.Object\");");
+				sw.WriteLine ("\t\t\tthis.implementor = implementor as Gst.GLib.Object;");
 				sw.WriteLine ("\t\t}");
 				sw.WriteLine ();
 			}
@@ -151,7 +151,7 @@
 			sw.WriteLine ("\t\t{");
 			sw.WriteLine ("\t\t\tif (!_gtype.IsInstance (handle))");
 			sw.WriteLine ("\t\t\t\tthrow new ArgumentException (\"The gobject doesn't implement the GInterface of this adapter\", \"handle\");");
-			sw.WriteLine ("\t\t\timplementor = GLib.Object.GetObject (handle);");
+			sw.WriteLine ("\t\t\timplementor = Gst.GLib.Object.GetObject (handle);");
 			sw.WriteLine ("\t\t}");
 			sw.WriteLine ();
 		}
@@ -160,9 +160,9 @@
 		{
 			Method m = GetMethod ("GetType");
 			m.GenerateImport (sw);
-			sw.WriteLine ("\t\tprivate static GLib.GType _gtype = new GLib.GType ({0} ());", m.CName);
+			sw.WriteLine ("\t\tprivate static Gst.GLib.GType _gtype = new Gst.GLib.GType ({0} ());", m.CName);
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tpublic override GLib.GType GType {");
+			sw.WriteLine ("\t\tpublic override Gst.GLib.GType GType {");
 			sw.WriteLine ("\t\t\tget {");
 			sw.WriteLine ("\t\t\t\treturn _gtype;");
 			sw.WriteLine ("\t\t\t}");
@@ -190,11 +190,11 @@
 		{
 			sw.WriteLine ("\t\tpublic static " + Name + " GetObject (IntPtr handle, bool owned)");
 			sw.WriteLine ("\t\t{");
-			sw.WriteLine ("\t\t\tGLib.Object obj = GLib.Object.GetObject (handle, owned);");
+			sw.WriteLine ("\t\t\tGst.GLib.Object obj = Gst.GLib.Object.GetObject (handle, owned);");
 			sw.WriteLine ("\t\t\treturn GetObject (obj);");
 			sw.WriteLine ("\t\t}");
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tpublic static " + Name + " GetObject (GLib.Object obj)");
+			sw.WriteLine ("\t\tpublic static " + Name + " GetObject (Gst.GLib.Object obj)");
 			sw.WriteLine ("\t\t{");
 			sw.WriteLine ("\t\t\tif (obj == null)");
 			sw.WriteLine ("\t\t\t\treturn null;");
@@ -230,7 +230,7 @@
 			sw.WriteLine ("\tusing System.Runtime.InteropServices;");
 			sw.WriteLine ();
 			sw.WriteLine ("#region Autogenerated code");
-			sw.WriteLine ("\tpublic partial class " + Name + "Adapter : GLib.GInterfaceAdapter, " + QualifiedName + " {");
+			sw.WriteLine ("\tpublic partial class " + Name + "Adapter : Gst.GLib.GInterfaceAdapter, " + QualifiedName + " {");
 			sw.WriteLine ();
 
 			if (!IsConsumeOnly) {
@@ -249,7 +249,7 @@
 			GenProperties (gen_info, null);
 
 			foreach (Signal sig in sigs.Values)
-				sig.GenEvent (sw, null, "GLib.Object.GetObject (Handle)");
+				sig.GenEvent (sw, null, "Gst.GLib.Object.GetObject (Handle)");
 
 			Method temp = methods ["GetType"] as Method;
 			if (temp != null)
@@ -275,9 +275,9 @@
 				return;
 
 			sw.WriteLine ();
-			sw.WriteLine ("\t[GLib.GInterface (typeof (" + Name + "Adapter))]");
+			sw.WriteLine ("\t[Gst.GLib.GInterface (typeof (" + Name + "Adapter))]");
 			string access = IsInternal ? "internal" : "public";
-			sw.WriteLine ("\t" + access + " partial interface " + Name + "Implementor : GLib.IWrapper {");
+			sw.WriteLine ("\t" + access + " partial interface " + Name + "Implementor : Gst.GLib.IWrapper {");
 			sw.WriteLine ();
 			Hashtable vm_table = new Hashtable ();
 			foreach (InterfaceVM vm in interface_vms) {
@@ -323,7 +323,7 @@
 			sw.WriteLine ();
 			sw.WriteLine ("#region Autogenerated code");
 			string access = IsInternal ? "internal" : "public";
-			sw.WriteLine ("\t" + access + " partial interface " + Name + " : GLib.IWrapper {");
+			sw.WriteLine ("\t" + access + " partial interface " + Name + " : Gst.GLib.IWrapper {");
 			sw.WriteLine ();
 			
 			foreach (Signal sig in sigs.Values) {
diff -Naur generator-upstream/Makefile generator/Makefile
diff -Naur generator-upstream/Makefile.am generator/Makefile.am
diff -Naur generator-upstream/Makefile.in generator/Makefile.in
diff -Naur generator-upstream/ManagedCallString.cs generator/ManagedCallString.cs
--- generator-upstream/ManagedCallString.cs	2009-08-13 16:46:33.000000000 +0200
+++ generator/ManagedCallString.cs	2009-11-25 08:07:47.000000000 +0100
@@ -50,12 +50,15 @@
 					error_param = p.Name;
 					continue;
 				}
+
 				this.parms.Add (p);
 
 				if (p.PassAs != String.Empty && (p.Name != p.FromNative (p.Name)))
 					this.special.Add (true);
 				else if (p.Generatable is CallbackGen)
 					this.special.Add (true);
+				else if (p.Scope == "call")
+					this.special.Add (true);
 				else
 					this.special.Add (false);
 			}
@@ -96,6 +99,11 @@
 						ret += indent + String.Format ("{0} {1}_invoker = new {0} ({1}, {2});\n", (igen as CallbackGen).InvokerName, p.Name, user_data_param);
 					else
 						ret += indent + String.Format ("{0} {1}_invoker = new {0} ({1}, {2}, {3});\n", (igen as CallbackGen).InvokerName, p.Name, user_data_param, destroy_param);
+				} else if (p.Scope == "call") {
+					if (igen is ObjectBase)
+						ret += indent + igen.QualifiedName + " my" + p.Name + " = " + (igen as ObjectBase).FromNative (p.Name, true) + ";\n";
+					else
+						throw new NotImplementedException();
 				} else {
 					ret += indent + igen.QualifiedName + " my" + p.Name;
 					if (p.PassAs == "ref")
@@ -137,16 +145,25 @@
 				Parameter p = parms [i] as Parameter;
 				IGeneratable igen = p.Generatable;
 
-				if (igen is CallbackGen)
+				if (igen is CallbackGen) {
 					continue;
-				else if (igen is StructBase || igen is ByRefGen)
+				} else if (igen is StructBase || igen is ByRefGen) {
 					ret += indent + String.Format ("if ({0} != IntPtr.Zero) System.Runtime.InteropServices.Marshal.StructureToPtr (my{0}, {0}, false);\n", p.Name);
-				else if (igen is IManualMarshaler)
+				} else if (igen is IManualMarshaler) {
 					ret += String.Format ("{0}{1} = {2};", indent, p.Name, (igen as IManualMarshaler).AllocNative ("my" + p.Name));
-				else
+				} else if (p.Scope == "call") {
+					if (igen is ObjectBase || igen is OpaqueGen) {
+						if (igen is ObjectBase)
+							ret += indent + "IntPtr dummy = my" + p.Name + ".OwnedHandle;\n";
+						else
+							throw new NotImplementedException();
+
+						ret += indent + "my" + p.Name + ".Dispose();\n";
+					}
+				} else {
 					ret += indent + p.Name + " = " + igen.CallByName ("my" + p.Name) + ";\n";
+				}
 			}
-
 			return ret;
 		}
 	}
diff -Naur generator-upstream/MethodBody.cs generator/MethodBody.cs
--- generator-upstream/MethodBody.cs	2009-01-07 18:10:08.000000000 +0100
+++ generator/MethodBody.cs	2009-11-25 08:07:47.000000000 +0100
@@ -111,7 +111,7 @@
 						sw.WriteLine (indent + "\t\t\t\t{0} = null;", parameters [i + 2].Name);
 						sw.WriteLine (indent + "\t\t\t} else {");
 						sw.WriteLine (indent + "\t\t\t\t{0} = (IntPtr) GCHandle.Alloc ({1}_wrapper);", parameters [i + 1].Name, name);
-						sw.WriteLine (indent + "\t\t\t\t{0} = GLib.DestroyHelper.NotifyHandler;", parameters [i + 2].Name, parameters [i + 2].CSType);
+						sw.WriteLine (indent + "\t\t\t\t{0} = Gst.GLib.DestroyHelper.NotifyHandler;", parameters [i + 2].Name, parameters [i + 2].CSType);
 						sw.WriteLine (indent + "\t\t\t}");
 						break;
 
@@ -154,7 +154,7 @@
 		{
 			if (!ThrowsException)
 				return;
-			sw.WriteLine (indent + "\t\t\tif (error != IntPtr.Zero) throw new GLib.GException (error);");
+			sw.WriteLine (indent + "\t\t\tif (error != IntPtr.Zero) throw new Gst.GLib.GException (error);");
 		}
 		
 		public bool ThrowsException {
diff -Naur generator-upstream/Method.cs generator/Method.cs
--- generator-upstream/Method.cs	2009-09-03 21:50:53.000000000 +0200
+++ generator/Method.cs	2009-11-25 08:07:47.000000000 +0100
@@ -118,7 +118,7 @@
 
 			if (Name == "ToString" && Parameters.Count == 0)
 				sw.Write("override ");
-			else if (Name == "GetGType" && container_type is ObjectGen)
+			else if (Name == "GetGType" && (container_type is ObjectGen || container_type is MiniObjectGen))
 				sw.Write("new ");
 			else if (Modifiers == "new " || (dup != null && ((dup.Signature != null && Signature != null && dup.Signature.ToString() == Signature.ToString()) || (dup.Signature == null && Signature == null))))
 				sw.Write("new ");
diff -Naur generator-upstream/MiniObjectGen.cs generator/MiniObjectGen.cs
--- generator-upstream/MiniObjectGen.cs	1970-01-01 01:00:00.000000000 +0100
+++ generator/MiniObjectGen.cs	2009-10-03 11:56:16.000000000 +0200
@@ -0,0 +1,326 @@
+// GtkSharp.Generation.MiniObjectGen.cs - The Mini Object Generatable.
+//
+// Author: Mike Kestner <mkestner@ximian.com>
+//
+// Copyright (c) 2001-2003 Mike Kestner
+// Copyright (c) 2003-2004 Novell, Inc.
+// Copyright (c) 2009 Sebastian Dröge <sebastian.droege@collabora.co.uk>.
+//
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of version 2 of the GNU General Public
+// License as published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// General Public License for more details.
+//
+// You should have received a copy of the GNU General Public
+// License along with this program; if not, write to the
+// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+
+namespace GtkSharp.Generation {
+
+	using System;
+	using System.Collections;
+	using System.IO;
+	using System.Text;
+	using System.Xml;
+
+	public class MiniObjectGen : ObjectBase  {
+
+		private ArrayList custom_attrs = new ArrayList();
+		private ArrayList strings = new ArrayList();
+		private static Hashtable dirs = new Hashtable ();
+
+		public MiniObjectGen (XmlElement ns, XmlElement elem) : base (ns, elem, false) 
+		{
+			foreach (XmlNode node in elem.ChildNodes) {
+				if (!(node is XmlElement)) continue;
+				XmlElement member = (XmlElement) node;
+				if (member.HasAttribute ("hidden") && member.GetAttribute ("hidden") == "1") continue;
+
+				switch (node.Name) {
+				case "custom-attribute":
+					custom_attrs.Add (member.InnerXml);
+					break;
+
+				case "static-string":
+					strings.Add (node);
+					break;
+
+				default:
+					if (!IsNodeNameHandled (node.Name))
+						Console.WriteLine ("Unexpected node " + node.Name + " in " + CName);
+					break;
+				}
+			}
+		}
+
+		public override string CallByName (string var, bool owned)
+		{
+			return String.Format ("{0} == null ? IntPtr.Zero : {0}.{1}", var, owned ? "OwnedHandle" : "Handle");
+		}
+
+		public override bool Validate ()
+		{
+			ArrayList invalids = new ArrayList ();
+
+			return base.Validate ();
+		}
+
+		private bool DisableVoidCtor {
+			get {
+				return Elem.HasAttribute ("disable_void_ctor");
+			}
+		}
+
+		private bool DisableGTypeCtor {
+			get {
+				return Elem.HasAttribute ("disable_gtype_ctor");
+			}
+		}
+
+		private class DirectoryInfo {
+			public string assembly_name;
+			public Hashtable objects;
+
+			public DirectoryInfo (string assembly_name) {
+				this.assembly_name = assembly_name;
+				objects = new Hashtable ();
+			}
+		}
+
+		private static DirectoryInfo GetDirectoryInfo (string dir, string assembly_name)
+		{
+			DirectoryInfo result;
+
+			if (dirs.ContainsKey (dir)) {
+				result = dirs [dir] as DirectoryInfo;
+				if  (result.assembly_name != assembly_name) {
+					Console.WriteLine ("Can't put multiple assemblies in one directory.");
+					return null;
+				}
+
+				return result;
+			}
+
+			result = new DirectoryInfo (assembly_name);
+			dirs.Add (dir, result);
+			
+			return result;
+		}
+
+		public override void Generate (GenerationInfo gen_info)
+		{
+			gen_info.CurrentType = Name;
+
+			string asm_name = gen_info.AssemblyName.Length == 0 ? NS.ToLower () + "-sharp" : gen_info.AssemblyName;
+			DirectoryInfo di = GetDirectoryInfo (gen_info.Dir, asm_name);
+
+			StreamWriter sw = gen_info.Writer = gen_info.OpenStream (Name);
+
+			sw.WriteLine ("namespace " + NS + " {");
+			sw.WriteLine ();
+			sw.WriteLine ("\tusing System;");
+			sw.WriteLine ("\tusing System.Collections;");
+			sw.WriteLine ("\tusing System.Runtime.InteropServices;");
+			sw.WriteLine ();
+
+			SymbolTable table = SymbolTable.Table;
+
+			sw.WriteLine ("#region Autogenerated code");
+			if (IsDeprecated)
+				sw.WriteLine ("\t[Obsolete]");
+			foreach (string attr in custom_attrs)
+				sw.WriteLine ("\t" + attr);
+			sw.Write ("\t{0} {1}class " + Name, IsInternal ? "internal" : "public", IsAbstract ? "abstract " : "");
+			string cs_parent = table.GetCSType(Elem.GetAttribute("parent"));
+			if (cs_parent != "") {
+				di.objects.Add (CName, QualifiedName);
+				sw.Write (" : " + cs_parent);
+			}
+			foreach (string iface in managed_interfaces) {
+				if (Parent != null && Parent.Implements (iface))
+					continue;
+				sw.Write (", " + iface);
+			}
+			sw.WriteLine (" {");
+			sw.WriteLine ();
+
+			GenCtors (gen_info);
+			GenFields (gen_info);
+			
+			GenClassMembers (gen_info, cs_parent);
+			GenMethods (gen_info, null, null);
+			
+			foreach (XmlElement str in strings) {
+				sw.Write ("\t\tpublic static string " + str.GetAttribute ("name"));
+				sw.WriteLine (" {\n\t\t\t get { return \"" + str.GetAttribute ("value") + "\"; }\n\t\t}");
+			}
+
+			if (cs_parent != String.Empty && GetExpected (CName) != QualifiedName) {
+				sw.WriteLine ();
+				sw.WriteLine ("\t\tstatic " + Name + " ()");
+				sw.WriteLine ("\t\t{");
+				sw.WriteLine ("\t\t\tGtkSharp." + Studlify (asm_name) + ".ObjectManager.Initialize ();");
+				sw.WriteLine ("\t\t}");
+			}
+
+			sw.WriteLine ("#endregion");
+			AppendCustom (sw, gen_info.CustomDir);
+
+			sw.WriteLine ("\t}");
+			sw.WriteLine ("}");
+
+			sw.Close ();
+			gen_info.Writer = null;
+			Statistics.ObjectCount++;
+		}
+
+		protected override void GenCtors (GenerationInfo gen_info)
+		{
+			if (!Elem.HasAttribute("parent"))
+				return;
+
+			if (!DisableGTypeCtor) {
+				gen_info.Writer.WriteLine("\t\t[Obsolete]");
+				gen_info.Writer.WriteLine("\t\tprotected " + Name + "(Gst.GLib.GType gtype) : base(gtype) {}");
+			}
+			gen_info.Writer.WriteLine("\t\tpublic " + Name + "(IntPtr raw) : base(raw) {}");
+			if (ctors.Count == 0 && !DisableVoidCtor) {
+				gen_info.Writer.WriteLine();
+				gen_info.Writer.WriteLine("\t\tprotected " + Name + "() : base(IntPtr.Zero)");
+				gen_info.Writer.WriteLine("\t\t{");
+				gen_info.Writer.WriteLine("\t\t\tCreateNativeObject ();");
+				gen_info.Writer.WriteLine("\t\t}");
+			}
+			gen_info.Writer.WriteLine();
+
+			base.GenCtors (gen_info);
+		}
+
+		void GenClassMembers (GenerationInfo gen_info, string cs_parent)
+		{
+			GenVirtualMethods (gen_info, null);
+
+			if (class_struct_name == null || !CanGenerateClassStruct) return;
+			StreamWriter sw = gen_info.Writer;
+			GenerateClassStruct (gen_info);
+			if (cs_parent == "")
+				sw.WriteLine ("\t\tstatic uint class_offset = 0;");
+			else
+				sw.WriteLine ("\t\tstatic uint class_offset = ((Gst.GLib.GType) typeof ({0})).GetClassSize ();", cs_parent);
+			sw.WriteLine ("\t\tstatic Hashtable class_structs;");
+			sw.WriteLine ();
+			sw.WriteLine ("\t\tstatic {0} GetClassStruct (Gst.GLib.GType gtype, bool use_cache)", class_struct_name);
+			sw.WriteLine ("\t\t{");
+			sw.WriteLine ("\t\t\tif (class_structs == null)");
+			sw.WriteLine ("\t\t\t\tclass_structs = new Hashtable ();");
+			sw.WriteLine ();
+			sw.WriteLine ("\t\t\tif (use_cache && class_structs.Contains (gtype))");
+			sw.WriteLine ("\t\t\t\treturn ({0}) class_structs [gtype];", class_struct_name);
+			sw.WriteLine ("\t\t\telse {");
+			sw.WriteLine ("\t\t\t\tIntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);");
+			sw.WriteLine ("\t\t\t\t{0} class_struct = ({0}) Marshal.PtrToStructure (class_ptr, typeof ({0}));", class_struct_name);
+			sw.WriteLine ("\t\t\t\tif (use_cache)");
+			sw.WriteLine ("\t\t\t\t\tclass_structs.Add (gtype, class_struct);");
+			sw.WriteLine ("\t\t\t\treturn class_struct;");
+			sw.WriteLine ("\t\t\t}");
+			sw.WriteLine ("\t\t}");
+			sw.WriteLine ();
+			sw.WriteLine ("\t\tstatic void OverrideClassStruct (Gst.GLib.GType gtype, {0} class_struct)", class_struct_name);
+			sw.WriteLine ("\t\t{");
+			sw.WriteLine ("\t\t\tIntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);");
+			sw.WriteLine ("\t\t\tMarshal.StructureToPtr (class_struct, class_ptr, false);");
+			sw.WriteLine ("\t\t}");
+			sw.WriteLine ();
+		}
+
+		/* Keep this in sync with the one in glib/GType.cs */
+		private static string GetExpected (string cname)
+		{
+			for (int i = 1; i < cname.Length; i++) {
+				if (Char.IsUpper (cname[i])) {
+					if (i == 1 && cname[0] == 'G')
+						return "Gst.GLib." + cname.Substring (1);
+					else
+						return cname.Substring (0, i) + "." + cname.Substring (i);
+				}
+			}
+
+			throw new ArgumentException ("cname doesn't follow the NamespaceType capitalization style: " + cname);
+		}
+
+		private static bool NeedsMap (Hashtable objs, string assembly_name)
+		{
+			foreach (string key in objs.Keys)
+				if (GetExpected (key) != ((string) objs[key]))
+					return true;
+			
+			return false;
+		}
+
+		private static string Studlify (string name)
+		{
+			string result = "";
+
+			string[] subs = name.Split ('-');
+			foreach (string sub in subs)
+				result += Char.ToUpper (sub[0]) + sub.Substring (1);
+				
+			return result;
+		}
+				
+		public static void GenerateMappers ()
+		{
+			foreach (string dir in dirs.Keys) {
+
+				DirectoryInfo di = dirs[dir] as DirectoryInfo;
+
+				if (!NeedsMap (di.objects, di.assembly_name))
+					continue;
+	
+				GenerationInfo gen_info = new GenerationInfo (dir, di.assembly_name);
+
+				GenerateMapper (di, gen_info);
+			}
+		}
+
+		private static void GenerateMapper (DirectoryInfo dir_info, GenerationInfo gen_info)
+		{
+			StreamWriter sw = gen_info.OpenStream ("ObjectManager");
+
+			sw.WriteLine ("namespace GtkSharp." + Studlify (dir_info.assembly_name) + " {");
+			sw.WriteLine ();
+			sw.WriteLine ("\tpublic class ObjectManager {");
+			sw.WriteLine ();
+			sw.WriteLine ("\t\tstatic bool initialized = false;");
+			sw.WriteLine ("\t\t// Call this method from the appropriate module init function.");
+			sw.WriteLine ("\t\tpublic static void Initialize ()");
+			sw.WriteLine ("\t\t{");
+			sw.WriteLine ("\t\t\tif (initialized)");
+			sw.WriteLine ("\t\t\t\treturn;");
+			sw.WriteLine ("");
+			sw.WriteLine ("\t\t\tinitialized = true;");
+	
+			foreach (string key in dir_info.objects.Keys) {
+				if (GetExpected(key) != ((string) dir_info.objects[key]))
+					sw.WriteLine ("\t\t\tGst.GLib.GType.Register ({0}.GType, typeof ({0}));", dir_info.objects [key]);
+			}
+					
+			sw.WriteLine ("\t\t}");
+			sw.WriteLine ("\t}");
+			sw.WriteLine ("}");
+			sw.Close ();
+		}
+
+		public override string FromNative (string var, bool owned)
+		{
+			return "Gst.MiniObject.GetObject(" + var + (owned ? ", true" : "") + ") as " + QualifiedName;
+		}
+	}
+}
+
diff -Naur generator-upstream/MiniObjectGen.cs.rej generator/MiniObjectGen.cs.rej
diff -Naur generator-upstream/ObjectBase.cs generator/ObjectBase.cs
--- generator-upstream/ObjectBase.cs	2009-08-05 08:24:27.000000000 +0200
+++ generator/ObjectBase.cs	2009-11-25 08:07:54.000000000 +0100
@@ -164,7 +164,7 @@
 
 		public override string FromNative (string var, bool owned)
 		{
-			return "GLib.Object.GetObject(" + var + (owned ? ", true" : "") + ") as " + QualifiedName;
+			return "Gst.GLib.Object.GetObject(" + var + (owned ? ", true" : "") + ") as " + QualifiedName;
 		}
 
 		public string ClassStructName {
diff -Naur generator-upstream/ObjectGen.cs generator/ObjectGen.cs
--- generator-upstream/ObjectGen.cs	2009-08-19 18:13:17.000000000 +0200
+++ generator/ObjectGen.cs	2009-11-25 08:07:54.000000000 +0100
@@ -253,7 +253,7 @@
 				gen_info.Writer.WriteLine();
 				gen_info.Writer.WriteLine("\t\tprotected " + Name + "() : base(IntPtr.Zero)");
 				gen_info.Writer.WriteLine("\t\t{");
-				gen_info.Writer.WriteLine("\t\t\tCreateNativeObject (new string [0], new GLib.Value [0]);");
+				gen_info.Writer.WriteLine("\t\t\tCreateNativeObject (new string [0], new Gst.GLib.Value [0]);");
 				gen_info.Writer.WriteLine("\t\t}");
 			}
 			gen_info.Writer.WriteLine();
@@ -302,10 +302,10 @@
 			if (cs_parent == "")
 				sw.WriteLine ("\t\tstatic uint class_offset = 0;");
 			else
-				sw.WriteLine ("\t\tstatic uint class_offset = ((GLib.GType) typeof ({0})).GetClassSize ();", cs_parent);
+				sw.WriteLine ("\t\tstatic uint class_offset = ((Gst.GLib.GType) typeof ({0})).GetClassSize ();", cs_parent);
 			sw.WriteLine ("\t\tstatic Hashtable class_structs;");
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tstatic {0} GetClassStruct (GLib.GType gtype, bool use_cache)", class_struct_name);
+			sw.WriteLine ("\t\tstatic {0} GetClassStruct (Gst.GLib.GType gtype, bool use_cache)", class_struct_name);
 			sw.WriteLine ("\t\t{");
 			sw.WriteLine ("\t\t\tif (class_structs == null)");
 			sw.WriteLine ("\t\t\t\tclass_structs = new Hashtable ();");
@@ -321,7 +321,7 @@
 			sw.WriteLine ("\t\t\t}");
 			sw.WriteLine ("\t\t}");
 			sw.WriteLine ();
-			sw.WriteLine ("\t\tstatic void OverrideClassStruct (GLib.GType gtype, {0} class_struct)", class_struct_name);
+			sw.WriteLine ("\t\tstatic void OverrideClassStruct (Gst.GLib.GType gtype, {0} class_struct)", class_struct_name);
 			sw.WriteLine ("\t\t{");
 			sw.WriteLine ("\t\t\tIntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);");
 			sw.WriteLine ("\t\t\tMarshal.StructureToPtr (class_struct, class_ptr, false);");
@@ -335,7 +335,7 @@
 			for (int i = 1; i < cname.Length; i++) {
 				if (Char.IsUpper (cname[i])) {
 					if (i == 1 && cname[0] == 'G')
-						return "GLib." + cname.Substring (1);
+						return "Gst.GLib." + cname.Substring (1);
 					else
 						return cname.Substring (0, i) + "." + cname.Substring (i);
 				}
@@ -398,7 +398,7 @@
 	
 			foreach (string key in dir_info.objects.Keys) {
 				if (GetExpected(key) != ((string) dir_info.objects[key]))
-					sw.WriteLine ("\t\t\tGLib.GType.Register ({0}.GType, typeof ({0}));", dir_info.objects [key]);
+					sw.WriteLine ("\t\t\tGst.GLib.GType.Register ({0}.GType, typeof ({0}));", dir_info.objects [key]);
 			}
 					
 			sw.WriteLine ("\t\t}");
diff -Naur generator-upstream/OpaqueGen.cs generator/OpaqueGen.cs
--- generator-upstream/OpaqueGen.cs	2009-08-19 18:13:17.000000000 +0200
+++ generator/OpaqueGen.cs	2009-11-25 08:07:54.000000000 +0100
@@ -32,7 +32,7 @@
 	
 		public override string FromNative(string var, bool owned)
 		{
-			return var + " == IntPtr.Zero ? null : (" + QualifiedName + ") GLib.Opaque.GetOpaque (" + var + ", typeof (" + QualifiedName + "), " + (owned ? "true" : "false") + ")";
+			return var + " == IntPtr.Zero ? null : (" + QualifiedName + ") Gst.GLib.Opaque.GetOpaque (" + var + ", typeof (" + QualifiedName + "), " + (owned ? "true" : "false") + ")";
 		}
 
 		private bool DisableRawCtor {
@@ -68,7 +68,7 @@
 			if (cs_parent != "")
 				sw.Write (" : " + cs_parent);
 			else
-				sw.Write (" : GLib.Opaque");
+				sw.Write (" : Gst.GLib.Opaque");
 
 			foreach (string iface in managed_interfaces) {
 				if (Parent != null && Parent.Implements (iface))
@@ -165,7 +165,7 @@
 				sw.WriteLine ("\t\t\tif (!Owned)");
 				sw.WriteLine ("\t\t\t\treturn;");
 				sw.WriteLine ("\t\t\tFinalizerInfo info = new FinalizerInfo (Handle);");
-				sw.WriteLine ("\t\t\tGLib.Timeout.Add (50, new GLib.TimeoutHandler (info.Handler));");
+				sw.WriteLine ("\t\t\tGst.GLib.Timeout.Add (50, new Gst.GLib.TimeoutHandler (info.Handler));");
 				sw.WriteLine ("\t\t}");
 				sw.WriteLine ();
 			}
@@ -173,9 +173,9 @@
 #if false
 			Method copy = Methods ["Copy"] as Method;
 			if (copy != null && copy.Parameters.Count == 0) {
-				sw.WriteLine ("\t\tprotected override GLib.Opaque Copy (IntPtr raw)");
+				sw.WriteLine ("\t\tprotected override Gst.GLib.Opaque Copy (IntPtr raw)");
 				sw.WriteLine ("\t\t{");
-				sw.WriteLine ("\t\t\tGLib.Opaque result = new " + QualifiedName + " (" + copy.CName + " (raw));");
+				sw.WriteLine ("\t\t\tGst.GLib.Opaque result = new " + QualifiedName + " (" + copy.CName + " (raw));");
 				sw.WriteLine ("\t\t\tresult.Owned = true;");
 				sw.WriteLine ("\t\t\treturn result;");
 				sw.WriteLine ("\t\t}");
diff -Naur generator-upstream/Parameters.cs generator/Parameters.cs
--- generator-upstream/Parameters.cs	2009-07-13 00:01:52.000000000 +0200
+++ generator/Parameters.cs	2009-11-25 08:07:54.000000000 +0100
@@ -263,9 +263,9 @@
 				} else if (gen is IManualMarshaler)
 					call_parm = "native_" + CallName;
 				else if (gen is ObjectBase)
-					call_parm = (gen as ObjectBase).CallByName (CallName, Owned);
+					call_parm = (gen as ObjectBase).CallByName(CallName, Owned);
 				else
-					call_parm = gen.CallByName (CallName);
+					call_parm = gen.CallByName(CallName);
 			
 				return call_parm;
 			}
diff -Naur generator-upstream/Parser.cs generator/Parser.cs
--- generator-upstream/Parser.cs	2009-04-13 19:44:48.000000000 +0200
+++ generator/Parser.cs	2009-11-25 08:07:54.000000000 +0100
@@ -138,6 +138,9 @@
 				case "object":
 					result.Add (new ObjectGen (ns, elem));
 					break;
+				case "mini-object":
+					result.Add (new MiniObjectGen (ns, elem));
+					break;
 				case "class":
 					result.Add (new ClassGen (ns, elem));
 					break;
diff -Naur generator-upstream/Property.cs generator/Property.cs
--- generator-upstream/Property.cs	2008-09-17 01:21:50.000000000 +0200
+++ generator/Property.cs	2009-11-25 08:07:54.000000000 +0100
@@ -64,7 +64,7 @@
 		}
 
 		protected virtual string PropertyAttribute (string qpname) {
-			return "[GLib.Property (" + qpname + ")]";
+			return "[Gst.GLib.Property (" + qpname + ")]";
 		}
 
 		protected virtual string RawGetter (string qpname) {
@@ -117,9 +117,9 @@
 
 			string v_type = "";
 			if (table.IsInterface (CType)) {
-				v_type = "(GLib.Object)";
+				v_type = "(Gst.GLib.Object)";
 			} else if (table.IsOpaque (CType)) {
-				v_type = "(GLib.Opaque)";
+				v_type = "(Gst.GLib.Opaque)";
 			} else if (table.IsEnum (CType)) {
 				v_type = "(Enum)";
 			}
@@ -140,12 +140,12 @@
 				sw.WriteLine();
 			} else if (Readable) {
 				sw.WriteLine(indent + "get {");
-				sw.WriteLine(indent + "\tGLib.Value val = " + RawGetter (qpname) + ";");
+				sw.WriteLine(indent + "\tGst.GLib.Value val = " + RawGetter (qpname) + ";");
 				if (table.IsOpaque (CType) || table.IsBoxed (CType)) {
 					sw.WriteLine(indent + "\t" + CSType + " ret = (" + CSType + ") val;");
 				} else if (table.IsInterface (CType)) {
-					// Do we have to dispose the GLib.Object from the GLib.Value?
-					sw.WriteLine (indent + "\t{0} ret = {0}Adapter.GetObject ((GLib.Object) val);", CSType);
+					// Do we have to dispose the Gst.GLib.Object from the Gst.GLib.Value?
+					sw.WriteLine (indent + "\t{0} ret = {0}Adapter.GetObject ((Gst.GLib.Object) val);", CSType);
 				} else {
 					sw.Write(indent + "\t" + CSType + " ret = ");
 					sw.Write ("(" + CSType + ") ");
@@ -166,13 +166,13 @@
 				sw.WriteLine();
 			} else if (Writable) {
 				sw.WriteLine(indent + "set {");
-				sw.Write(indent + "\tGLib.Value val = ");
+				sw.Write(indent + "\tGst.GLib.Value val = ");
 				if (table.IsBoxed (CType)) {
-					sw.WriteLine("(GLib.Value) value;");
+					sw.WriteLine("(Gst.GLib.Value) value;");
 				} else if (table.IsOpaque (CType)) {
-					sw.WriteLine("new GLib.Value(value, \"{0}\");", CType);
+					sw.WriteLine("new Gst.GLib.Value(value, \"{0}\");", CType);
 				} else {
-					sw.Write("new GLib.Value(");
+					sw.Write("new Gst.GLib.Value(");
 					if (v_type != "" && !(table.IsObject (CType) || table.IsInterface (CType) || table.IsOpaque (CType))) {
 						sw.Write(v_type + " ");
 					}
diff -Naur generator-upstream/ReturnValue.cs generator/ReturnValue.cs
--- generator-upstream/ReturnValue.cs	2009-09-23 23:27:15.000000000 +0200
+++ generator/ReturnValue.cs	2009-11-25 08:07:54.000000000 +0100
@@ -114,7 +114,9 @@
 			get {
 				if (IGen == null)
 					return String.Empty;
-				return IGen.MarshalType + (is_array || is_null_term ? "[]" : String.Empty);
+				else if (is_null_term)
+					return "IntPtr";
+				return IGen.MarshalType + (is_array ? "[]" : String.Empty);
 			}
 		}
 
@@ -125,14 +127,14 @@
 
 			if (ElementType != String.Empty) {
 				string args = (owned ? "true" : "false") + ", " + (elements_owned ? "true" : "false");
-				if (IGen.QualifiedName == "GLib.PtrArray")
-					return String.Format ("({0}[]) GLib.Marshaller.PtrArrayToArray ({1}, {2}, typeof({0}))", ElementType, var, args);
+				if (IGen.QualifiedName == "Gst.GLib.PtrArray")
+					return String.Format ("({0}[]) Gst.GLib.Marshaller.PtrArrayToArray ({1}, {2}, typeof({0}))", ElementType, var, args);
 				else
-					return String.Format ("({0}[]) GLib.Marshaller.ListPtrToArray ({1}, typeof({2}), {3}, typeof({4}))", ElementType, var, IGen.QualifiedName, args, element_ctype == "gfilename*" ? "GLib.ListBase.FilenameString" : ElementType);
+					return String.Format ("({0}[]) Gst.GLib.Marshaller.ListPtrToArray ({1}, typeof({2}), {3}, typeof({4}))", ElementType, var, IGen.QualifiedName, args, element_ctype == "gfilename*" ? "Gst.GLib.ListBase.FilenameString" : ElementType);
 			} else if (IGen is HandleBase)
 				return ((HandleBase)IGen).FromNative (var, owned);
 			else if (is_null_term)
-				return String.Format ("GLib.Marshaller.NullTermPtrToStringArray ({0}, {1})", var, owned ? "true" : "false");
+				return String.Format ("Gst.Marshaller.NullTermPtrToStringArray ({0}, {1})", var, owned ? "true" : "false");
 			else
 				return IGen.FromNative (var);
 		}
@@ -146,11 +148,11 @@
 				string args = ", typeof (" + ElementType + "), " + (owned ? "true" : "false") + ", " + (elements_owned ? "true" : "false");
 				var = "new " + IGen.QualifiedName + "(" + var + args + ")";
 			} else if (is_null_term)
-				return String.Format ("GLib.Marshaller.StringArrayToNullTermPointer ({0})", var);
+				return String.Format ("Gst.Marshaller.StringArrayToNullTermPointer ({0})", var);
 
 			if (IGen is IManualMarshaler)
 				return (IGen as IManualMarshaler).AllocNative (var);
-			else if (IGen is ObjectGen && owned)
+			else if ((IGen is ObjectGen || IGen is MiniObjectGen) && owned)
 				return var + " == null ? IntPtr.Zero : " + var + ".OwnedHandle";
 			else if (IGen is OpaqueGen && owned)
 				return var + " == null ? IntPtr.Zero : " + var + ".OwnedCopy";
diff -Naur generator-upstream/Signal.cs generator/Signal.cs
--- generator-upstream/Signal.cs	2009-11-23 18:19:46.000000000 +0100
+++ generator/Signal.cs	2009-11-25 08:08:27.000000000 +0100
@@ -204,7 +204,7 @@
 			}
 			sw.WriteLine("\t\t\t} catch (Exception) {");
 			sw.WriteLine ("\t\t\t\tException ex = new Exception (\"args.RetVal or 'out' property unset or set to incorrect type in " + EventHandlerQualifiedName + " callback\");");
-			sw.WriteLine("\t\t\t\tGLib.ExceptionManager.RaiseUnhandledException (ex, true);");
+			sw.WriteLine("\t\t\t\tGst.GLib.ExceptionManager.RaiseUnhandledException (ex, true);");
 			
 			sw.WriteLine ("\t\t\t\t// NOTREACHED: above call doesn't return.");
 			sw.WriteLine ("\t\t\t\tthrow ex;");
@@ -228,15 +228,15 @@
 			sw.WriteLine("\t\t{");
 			sw.WriteLine("\t\t\t{0} args = new {0} ();", EventArgsQualifiedName);
 			sw.WriteLine("\t\t\ttry {");
-			sw.WriteLine("\t\t\t\tGLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;");
+			sw.WriteLine("\t\t\t\tGst.GLib.Signal sig = ((GCHandle) gch).Target as Gst.GLib.Signal;");
 			sw.WriteLine("\t\t\t\tif (sig == null)");
 			sw.WriteLine("\t\t\t\t\tthrow new Exception(\"Unknown signal GC handle received \" + gch);");
 			sw.WriteLine();
 			string finish = GenArgsInitialization (sw);
 			sw.WriteLine("\t\t\t\t{0} handler = ({0}) sig.Handler;", EventHandlerQualifiedName);
-			sw.WriteLine("\t\t\t\thandler (GLib.Object.GetObject (inst), args);");
+			sw.WriteLine("\t\t\t\thandler (Gst.GLib.Object.GetObject (inst), args);");
 			sw.WriteLine("\t\t\t} catch (Exception e) {");
-			sw.WriteLine("\t\t\t\tGLib.ExceptionManager.RaiseUnhandledException (e, false);");
+			sw.WriteLine("\t\t\t\tGst.GLib.ExceptionManager.RaiseUnhandledException (e, false);");
 			sw.WriteLine("\t\t\t}");
 			GenArgsCleanup (sw, finish);
 			sw.WriteLine("\t\t}");
@@ -266,13 +266,13 @@
 			sw.WriteLine ();
 			sw.WriteLine ("\tpublic delegate void " + EventHandlerName + "(object o, " + EventArgsName + " args);");
 			sw.WriteLine ();
-			sw.WriteLine ("\tpublic class " + EventArgsName + " : GLib.SignalArgs {");
+			sw.WriteLine ("\tpublic class " + EventArgsName + " : Gst.GLib.SignalArgs {");
 			for (int i = 0; i < parms.Count; i++) {
 				sw.WriteLine ("\t\tpublic " + parms[i].CSType + " " + parms[i].StudlyName + "{");
 				if (parms[i].PassAs != "out") {
 					sw.WriteLine ("\t\t\tget {");
 					if (SymbolTable.Table.IsInterface (parms [i].CType))
-						sw.WriteLine ("\t\t\t\treturn {0}Adapter.GetObject (Args [{1}] as GLib.Object);", parms [i].CSType, i);
+						sw.WriteLine ("\t\t\t\treturn {0}Adapter.GetObject (Args [{1}] as Gst.GLib.Object);", parms [i].CSType, i);
 					else
 						sw.WriteLine ("\t\t\t\treturn ({0}) Args [{1}];", parms [i].CSType, i);
 					sw.WriteLine ("\t\t\t}");
@@ -302,17 +302,17 @@
 				args_type = ", new " + DelegateName + "(" + CallbackName + ")";
 			}
 
-			sw.WriteLine("\t\t[GLib.Signal("+ CName + ")]");
+			sw.WriteLine("\t\t[Gst.GLib.Signal("+ CName + ")]");
 			sw.Write("\t\tpublic ");
 			if (NeedNew (implementor))
 				sw.Write("new ");
 			sw.WriteLine("event " + EventHandlerQualifiedName + " " + Name + " {");
 			sw.WriteLine("\t\t\tadd {");
-			sw.WriteLine("\t\t\t\tGLib.Signal sig = GLib.Signal.Lookup (" + target + ", " + CName + args_type + ");");
+			sw.WriteLine("\t\t\t\tGst.GLib.Signal sig = Gst.GLib.Signal.Lookup (" + target + ", " + CName + args_type + ");");
 			sw.WriteLine("\t\t\t\tsig.AddDelegate (value);");
 			sw.WriteLine("\t\t\t}");
 			sw.WriteLine("\t\t\tremove {");
-			sw.WriteLine("\t\t\t\tGLib.Signal sig = GLib.Signal.Lookup (" + target + ", " + CName + args_type + ");");
+			sw.WriteLine("\t\t\t\tGst.GLib.Signal sig = Gst.GLib.Signal.Lookup (" + target + ", " + CName + args_type + ");");
 			sw.WriteLine("\t\t\t\tsig.RemoveDelegate (value);");
 			sw.WriteLine("\t\t\t}");
 			sw.WriteLine("\t\t}");
diff -Naur generator-upstream/Signal.cs.orig generator/Signal.cs.orig
diff -Naur generator-upstream/StructBase.cs generator/StructBase.cs
--- generator-upstream/StructBase.cs	2009-08-19 18:13:17.000000000 +0200
+++ generator/StructBase.cs	2009-11-25 08:07:54.000000000 +0100
@@ -92,7 +92,7 @@
 		
 		public string AllocNative (string var)
 		{
-			return "GLib.Marshaller.StructureToPtrAlloc (" + var + ")";
+			return "Gst.GLib.Marshaller.StructureToPtrAlloc (" + var + ")";
 		}
 
 		public string ReleaseNative (string var)
diff -Naur generator-upstream/StructGen.cs generator/StructGen.cs
--- generator-upstream/StructGen.cs	2005-08-05 22:34:45.000000000 +0200
+++ generator/StructGen.cs	2009-11-25 08:07:54.000000000 +0100
@@ -36,8 +36,8 @@
 			StreamWriter sw = gen_info.Writer = gen_info.OpenStream (Name);
 			base.Generate (gen_info);
 			if (GetMethod ("GetType") == null && GetMethod ("GetGType") == null) {
-				sw.WriteLine ("\t\tprivate static GLib.GType GType {");
-				sw.WriteLine ("\t\t\tget { return GLib.GType.Pointer; }");
+				sw.WriteLine ("\t\tprivate static Gst.GLib.GType GType {");
+				sw.WriteLine ("\t\t\tget { return Gst.GLib.GType.Pointer; }");
 				sw.WriteLine ("\t\t}");
 			}
 			sw.WriteLine ("#endregion");
diff -Naur generator-upstream/SymbolTable.cs generator/SymbolTable.cs
--- generator-upstream/SymbolTable.cs	2009-08-13 16:46:33.000000000 +0200
+++ generator/SymbolTable.cs	2009-11-25 08:07:54.000000000 +0100
@@ -108,23 +108,24 @@
 			AddType (new ConstStringGen ("const-xmlChar"));
 			AddType (new ConstStringGen ("const-char"));
 			AddType (new ConstFilenameGen ("const-gfilename"));
-			AddType (new MarshalGen ("gfilename", "string", "IntPtr", "GLib.Marshaller.StringToFilenamePtr({0})", "GLib.Marshaller.FilenamePtrToStringGFree({0})"));
-			AddType (new MarshalGen ("gchar", "string", "IntPtr", "GLib.Marshaller.StringToPtrGStrdup({0})", "GLib.Marshaller.PtrToStringGFree({0})"));
-			AddType (new MarshalGen ("char", "string", "IntPtr", "GLib.Marshaller.StringToPtrGStrdup({0})", "GLib.Marshaller.PtrToStringGFree({0})"));
+			AddType (new MarshalGen ("gfilename", "string", "IntPtr", "Gst.GLib.Marshaller.StringToFilenamePtr({0})", "Gst.GLib.Marshaller.FilenamePtrToStringGFree({0})"));
+			AddType (new MarshalGen ("gchar", "string", "IntPtr", "Gst.GLib.Marshaller.StringToPtrGStrdup({0})", "Gst.GLib.Marshaller.PtrToStringGFree({0})"));
+			AddType (new MarshalGen ("char", "string", "IntPtr", "Gst.GLib.Marshaller.StringToPtrGStrdup({0})", "Gst.GLib.Marshaller.PtrToStringGFree({0})"));
 			AddType (new SimpleGen ("GStrv", "string[]", "null"));
 
 			// manually wrapped types requiring more complex marshaling
-			AddType (new ManualGen ("GInitiallyUnowned", "GLib.InitiallyUnowned", "GLib.Object.GetObject ({0})"));
-			AddType (new ManualGen ("GObject", "GLib.Object", "GLib.Object.GetObject ({0})"));
-			AddType (new ManualGen ("GList", "GLib.List"));
-			AddType (new ManualGen ("GPtrArray", "GLib.PtrArray"));
-			AddType (new ManualGen ("GSList", "GLib.SList"));
-			AddType (new MarshalGen ("gunichar", "char", "uint", "GLib.Marshaller.CharToGUnichar ({0})", "GLib.Marshaller.GUnicharToChar ({0})"));
-			AddType (new MarshalGen ("time_t", "System.DateTime", "IntPtr", "GLib.Marshaller.DateTimeTotime_t ({0})", "GLib.Marshaller.time_tToDateTime ({0})"));
-			AddType (new MarshalGen ("GString", "string", "IntPtr", "new GLib.GString ({0}).Handle", "GLib.GString.PtrToString ({0})"));
-			AddType (new MarshalGen ("GType", "GLib.GType", "IntPtr", "{0}.Val", "new GLib.GType({0})", "GLib.GType.None"));
-			AddType (new ByRefGen ("GValue", "GLib.Value"));
-			AddType (new SimpleGen ("GDestroyNotify", "GLib.DestroyNotify", "null"));
+			AddType (new ManualGen ("GInitiallyUnowned", "Gst.GLib.InitiallyUnowned", "Gst.GLib.Object.GetObject ({0})"));
+			AddType (new ManualGen ("GObject", "Gst.GLib.Object", "Gst.GLib.Object.GetObject ({0})"));
+			AddType (new ManualGen ("GstMiniObject", "Gst.MiniObject", "Gst.MiniObject.GetObject ({0})"));
+			AddType (new ManualGen ("GList", "Gst.GLib.List"));
+			AddType (new ManualGen ("GPtrArray", "Gst.GLib.PtrArray"));
+			AddType (new ManualGen ("GSList", "Gst.GLib.SList"));
+			AddType (new MarshalGen ("gunichar", "char", "uint", "Gst.GLib.Marshaller.CharToGUnichar ({0})", "Gst.GLib.Marshaller.GUnicharToChar ({0})"));
+			AddType (new MarshalGen ("time_t", "System.DateTime", "IntPtr", "Gst.GLib.Marshaller.DateTimeTotime_t ({0})", "Gst.GLib.Marshaller.time_tToDateTime ({0})"));
+			AddType (new MarshalGen ("GString", "string", "IntPtr", "new Gst.GLib.GString ({0}).Handle", "Gst.GLib.GString.PtrToString ({0})"));
+			AddType (new MarshalGen ("GType", "Gst.GLib.GType", "IntPtr", "{0}.Val", "new Gst.GLib.GType({0})", "Gst.GLib.GType.None"));
+			AddType (new ByRefGen ("GValue", "Gst.GLib.Value"));
+			AddType (new SimpleGen ("GDestroyNotify", "Gst.GLib.DestroyNotify", "null"));
 
 			// FIXME: These ought to be handled properly.
 			AddType (new SimpleGen ("GC", "IntPtr", "IntPtr.Zero"));
@@ -136,7 +137,7 @@
 			AddType (new SimpleGen ("GByteArray", "IntPtr", "IntPtr.Zero"));
 			AddType (new SimpleGen ("GData", "IntPtr", "IntPtr.Zero"));
 			AddType (new SimpleGen ("GIOChannel", "IntPtr", "IntPtr.Zero"));
-			AddType (new SimpleGen ("GTypeModule", "GLib.Object", "null"));
+			AddType (new SimpleGen ("GTypeModule", "Gst.GLib.Object", "null"));
 			AddType (new SimpleGen ("GHashTable", "System.IntPtr", "IntPtr.Zero"));
 			AddType (new SimpleGen ("va_list", "IntPtr", "IntPtr.Zero"));
 			AddType (new SimpleGen ("GParamSpec", "IntPtr", "IntPtr.Zero"));
@@ -306,7 +307,8 @@
 			
 		public bool IsObject(string c_type)
 		{
-			if (this[c_type] is ObjectGen)
+			if ((this[c_type] is ObjectGen) ||
+			    (this[c_type] is MiniObjectGen))
 				return true;
 
 			return false;
diff -Naur generator-upstream/VirtualMethod.cs generator/VirtualMethod.cs
--- generator-upstream/VirtualMethod.cs	2009-09-03 21:50:53.000000000 +0200
+++ generator/VirtualMethod.cs	2009-11-25 08:07:54.000000000 +0100
@@ -92,7 +92,7 @@
 				else
 					type = this.container_type.Name;
 
-				sw.WriteLine ("\t\t\t\t{0} __obj = GLib.Object.GetObject (inst, false) as {0};", type);
+				sw.WriteLine ("\t\t\t\t{0} __obj = Gst.GLib.Object.GetObject (inst, false) as {0};", type);
 			}
 
 			sw.Write (call.Setup ("\t\t\t\t"));
@@ -108,7 +108,7 @@
 
 			bool fatal = parms.HasOutParam || !retval.IsVoid;
 			sw.WriteLine ("\t\t\t} catch (Exception e) {");
-			sw.WriteLine ("\t\t\t\tGLib.ExceptionManager.RaiseUnhandledException (e, " + (fatal ? "true" : "false") + ");");
+			sw.WriteLine ("\t\t\t\tGst.GLib.ExceptionManager.RaiseUnhandledException (e, " + (fatal ? "true" : "false") + ");");
 			if (fatal) {
 				sw.WriteLine ("\t\t\t\t// NOTREACHED: above call does not return.");
 				sw.WriteLine ("\t\t\t\tthrow e;");
