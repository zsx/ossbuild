// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gst {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class Index : Gst.Object {

		public Index(IntPtr raw) : base(raw) {}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_index_new();

		public Index () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Index)) {
				CreateNativeObject (new string [0], new Gst.GLib.Value[0]);
				return;
			}
			Raw = gst_index_new();
		}

		[Gst.GLib.Property ("resolver")]
		public Gst.IndexResolverMethod Method {
			get {
				Gst.GLib.Value val = GetProperty ("resolver");
				Gst.IndexResolverMethod ret = (Gst.IndexResolverMethod) (Enum) val;
				val.Dispose ();
				return ret;
			}
			set {
				Gst.GLib.Value val = new Gst.GLib.Value((Enum) value);
				SetProperty("resolver", val);
				val.Dispose ();
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_index_set_resolver_full(IntPtr raw, GstSharp.IndexResolverNative resolver, IntPtr user_data, Gst.GLib.DestroyNotify user_data_destroy);

		public Gst.IndexResolver Resolver {
			set  {
				GstSharp.IndexResolverWrapper value_wrapper = new GstSharp.IndexResolverWrapper (value);
				IntPtr user_data;
				Gst.GLib.DestroyNotify user_data_destroy;
				if (value == null) {
					user_data = IntPtr.Zero;
					user_data_destroy = null;
				} else {
					user_data = (IntPtr) GCHandle.Alloc (value_wrapper);
					user_data_destroy = Gst.GLib.DestroyHelper.NotifyHandler;
				}
				gst_index_set_resolver_full(Handle, value_wrapper.NativeDelegate, user_data, user_data_destroy);
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_index_set_filter_full(IntPtr raw, GstSharp.IndexFilterNative filter, IntPtr user_data, Gst.GLib.DestroyNotify user_data_destroy);

		public Gst.IndexFilter Filter {
			set  {
				GstSharp.IndexFilterWrapper value_wrapper = new GstSharp.IndexFilterWrapper (value);
				IntPtr user_data;
				Gst.GLib.DestroyNotify user_data_destroy;
				if (value == null) {
					user_data = IntPtr.Zero;
					user_data_destroy = null;
				} else {
					user_data = (IntPtr) GCHandle.Alloc (value_wrapper);
					user_data_destroy = Gst.GLib.DestroyHelper.NotifyHandler;
				}
				gst_index_set_filter_full(Handle, value_wrapper.NativeDelegate, user_data, user_data_destroy);
			}
		}

		[Gst.GLib.Signal("entry-added")]
		public event Gst.EntryAddedHandler EntryAdded {
			add {
				Gst.GLib.Signal sig = Gst.GLib.Signal.Lookup (this, "entry-added", typeof (Gst.EntryAddedArgs));
				sig.AddDelegate (value);
			}
			remove {
				Gst.GLib.Signal sig = Gst.GLib.Signal.Lookup (this, "entry-added", typeof (Gst.EntryAddedArgs));
				sig.RemoveDelegate (value);
			}
		}

		static GetWriterIdNativeDelegate GetWriterId_cb_delegate;
		static GetWriterIdNativeDelegate GetWriterIdVMCallback {
			get {
				if (GetWriterId_cb_delegate == null)
					GetWriterId_cb_delegate = new GetWriterIdNativeDelegate (GetWriterId_cb);
				return GetWriterId_cb_delegate;
			}
		}

		static void OverrideGetWriterId (Gst.GLib.GType gtype)
		{
			OverrideGetWriterId (gtype, GetWriterIdVMCallback);
		}

		static void OverrideGetWriterId (Gst.GLib.GType gtype, GetWriterIdNativeDelegate callback)
		{
			GstIndexClass class_iface = GetClassStruct (gtype, false);
			class_iface.GetWriterId = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool GetWriterIdNativeDelegate (IntPtr inst, out int writer_id, IntPtr writer_string);

		static bool GetWriterId_cb (IntPtr inst, out int writer_id, IntPtr writer_string)
		{
			try {
				Index __obj = Gst.GLib.Object.GetObject (inst, false) as Index;
				bool __result = __obj.OnGetWriterId (out writer_id, Gst.GLib.Marshaller.PtrToStringGFree(writer_string));
				return __result;
			} catch (Exception e) {
				Gst.GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[Gst.GLib.DefaultSignalHandler(Type=typeof(Gst.Index), ConnectionMethod="OverrideGetWriterId")]
		protected virtual bool OnGetWriterId (out int writer_id, string writer_string)
		{
			return InternalGetWriterId (out writer_id, writer_string);
		}

		private bool InternalGetWriterId (out int writer_id, string writer_string)
		{
			GetWriterIdNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).GetWriterId;
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			bool __result = unmanaged (this.Handle, out writer_id, Gst.GLib.Marshaller.StringToPtrGStrdup(writer_string));
			return __result;
		}

		static CommitNativeDelegate Commit_cb_delegate;
		static CommitNativeDelegate CommitVMCallback {
			get {
				if (Commit_cb_delegate == null)
					Commit_cb_delegate = new CommitNativeDelegate (Commit_cb);
				return Commit_cb_delegate;
			}
		}

		static void OverrideCommit (Gst.GLib.GType gtype)
		{
			OverrideCommit (gtype, CommitVMCallback);
		}

		static void OverrideCommit (Gst.GLib.GType gtype, CommitNativeDelegate callback)
		{
			GstIndexClass class_iface = GetClassStruct (gtype, false);
			class_iface.Commit = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void CommitNativeDelegate (IntPtr inst, int id);

		static void Commit_cb (IntPtr inst, int id)
		{
			try {
				Index __obj = Gst.GLib.Object.GetObject (inst, false) as Index;
				__obj.OnCommit (id);
			} catch (Exception e) {
				Gst.GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[Gst.GLib.DefaultSignalHandler(Type=typeof(Gst.Index), ConnectionMethod="OverrideCommit")]
		protected virtual void OnCommit (int id)
		{
			InternalCommit (id);
		}

		private void InternalCommit (int id)
		{
			CommitNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).Commit;
			if (unmanaged == null) return;

			unmanaged (this.Handle, id);
		}

		static AddEntryNativeDelegate AddEntry_cb_delegate;
		static AddEntryNativeDelegate AddEntryVMCallback {
			get {
				if (AddEntry_cb_delegate == null)
					AddEntry_cb_delegate = new AddEntryNativeDelegate (AddEntry_cb);
				return AddEntry_cb_delegate;
			}
		}

		static void OverrideAddEntry (Gst.GLib.GType gtype)
		{
			OverrideAddEntry (gtype, AddEntryVMCallback);
		}

		static void OverrideAddEntry (Gst.GLib.GType gtype, AddEntryNativeDelegate callback)
		{
			GstIndexClass class_iface = GetClassStruct (gtype, false);
			class_iface.AddEntry = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void AddEntryNativeDelegate (IntPtr inst, IntPtr entry);

		static void AddEntry_cb (IntPtr inst, IntPtr entry)
		{
			try {
				Index __obj = Gst.GLib.Object.GetObject (inst, false) as Index;
				__obj.OnAddEntry (entry == IntPtr.Zero ? null : (Gst.IndexEntry) Gst.GLib.Opaque.GetOpaque (entry, typeof (Gst.IndexEntry), false));
			} catch (Exception e) {
				Gst.GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[Gst.GLib.DefaultSignalHandler(Type=typeof(Gst.Index), ConnectionMethod="OverrideAddEntry")]
		protected virtual void OnAddEntry (Gst.IndexEntry entry)
		{
			InternalAddEntry (entry);
		}

		private void InternalAddEntry (Gst.IndexEntry entry)
		{
			AddEntryNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).AddEntry;
			if (unmanaged == null) return;

			unmanaged (this.Handle, entry == null ? IntPtr.Zero : entry.Handle);
		}

		static GetAssocEntryNativeDelegate GetAssocEntry_cb_delegate;
		static GetAssocEntryNativeDelegate GetAssocEntryVMCallback {
			get {
				if (GetAssocEntry_cb_delegate == null)
					GetAssocEntry_cb_delegate = new GetAssocEntryNativeDelegate (GetAssocEntry_cb);
				return GetAssocEntry_cb_delegate;
			}
		}

		static void OverrideGetAssocEntry (Gst.GLib.GType gtype)
		{
			OverrideGetAssocEntry (gtype, GetAssocEntryVMCallback);
		}

		static void OverrideGetAssocEntry (Gst.GLib.GType gtype, GetAssocEntryNativeDelegate callback)
		{
			GstIndexClass class_iface = GetClassStruct (gtype, false);
			class_iface.GetAssocEntry = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetAssocEntryNativeDelegate (IntPtr inst, int id, int method, int flags, int format, long value);

		static IntPtr GetAssocEntry_cb (IntPtr inst, int id, int method, int flags, int format, long value)
		{
			try {
				Index __obj = Gst.GLib.Object.GetObject (inst, false) as Index;
				Gst.IndexEntry __result = __obj.OnGetAssocEntry (id, (Gst.IndexLookupMethod) method, (Gst.AssocFlags) flags, (Gst.Format) format, value);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				Gst.GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[Gst.GLib.DefaultSignalHandler(Type=typeof(Gst.Index), ConnectionMethod="OverrideGetAssocEntry")]
		protected virtual Gst.IndexEntry OnGetAssocEntry (int id, Gst.IndexLookupMethod method, Gst.AssocFlags flags, Gst.Format format, long value)
		{
			return InternalGetAssocEntry (id, method, flags, format, value);
		}

		private Gst.IndexEntry InternalGetAssocEntry (int id, Gst.IndexLookupMethod method, Gst.AssocFlags flags, Gst.Format format, long value)
		{
			GetAssocEntryNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).GetAssocEntry;
			if (unmanaged == null) return null;

			IntPtr __result = unmanaged (this.Handle, id, (int) method, (int) flags, (int) format, value);
			return __result == IntPtr.Zero ? null : (Gst.IndexEntry) Gst.GLib.Opaque.GetOpaque (__result, typeof (Gst.IndexEntry), false);
		}

		static EntryAddedNativeDelegate EntryAdded_cb_delegate;
		static EntryAddedNativeDelegate EntryAddedVMCallback {
			get {
				if (EntryAdded_cb_delegate == null)
					EntryAdded_cb_delegate = new EntryAddedNativeDelegate (EntryAdded_cb);
				return EntryAdded_cb_delegate;
			}
		}

		static void OverrideEntryAdded (Gst.GLib.GType gtype)
		{
			OverrideEntryAdded (gtype, EntryAddedVMCallback);
		}

		static void OverrideEntryAdded (Gst.GLib.GType gtype, EntryAddedNativeDelegate callback)
		{
			GstIndexClass class_iface = GetClassStruct (gtype, false);
			class_iface.EntryAdded = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void EntryAddedNativeDelegate (IntPtr inst, IntPtr entry);

		static void EntryAdded_cb (IntPtr inst, IntPtr entry)
		{
			try {
				Index __obj = Gst.GLib.Object.GetObject (inst, false) as Index;
				__obj.OnEntryAdded (entry == IntPtr.Zero ? null : (Gst.IndexEntry) Gst.GLib.Opaque.GetOpaque (entry, typeof (Gst.IndexEntry), false));
			} catch (Exception e) {
				Gst.GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[Gst.GLib.DefaultSignalHandler(Type=typeof(Gst.Index), ConnectionMethod="OverrideEntryAdded")]
		protected virtual void OnEntryAdded (Gst.IndexEntry entry)
		{
			InternalEntryAdded (entry);
		}

		private void InternalEntryAdded (Gst.IndexEntry entry)
		{
			EntryAddedNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).EntryAdded;
			if (unmanaged == null) return;

			unmanaged (this.Handle, entry == null ? IntPtr.Zero : entry.Handle);
		}

		[StructLayout (LayoutKind.Sequential)]
		struct GstIndexClass {
			public GetWriterIdNativeDelegate GetWriterId;
			public CommitNativeDelegate Commit;
			public AddEntryNativeDelegate AddEntry;
			public GetAssocEntryNativeDelegate GetAssocEntry;
			public EntryAddedNativeDelegate EntryAdded;
			[MarshalAs (UnmanagedType.ByValArray, SizeConst=4)]
			public IntPtr[] GstReserved;
		}

		static uint class_offset = ((Gst.GLib.GType) typeof (Gst.Object)).GetClassSize ();
		static Hashtable class_structs;

		static GstIndexClass GetClassStruct (Gst.GLib.GType gtype, bool use_cache)
		{
			if (class_structs == null)
				class_structs = new Hashtable ();

			if (use_cache && class_structs.Contains (gtype))
				return (GstIndexClass) class_structs [gtype];
			else {
				IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
				GstIndexClass class_struct = (GstIndexClass) Marshal.PtrToStructure (class_ptr, typeof (GstIndexClass));
				if (use_cache)
					class_structs.Add (gtype, class_struct);
				return class_struct;
			}
		}

		static void OverrideClassStruct (Gst.GLib.GType gtype, GstIndexClass class_struct)
		{
			IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
			Marshal.StructureToPtr (class_struct, class_ptr, false);
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_index_add_id(IntPtr raw, int id, IntPtr description);

		public Gst.IndexEntry AddId(int id, string description) {
			IntPtr raw_ret = gst_index_add_id(Handle, id, Gst.GLib.Marshaller.StringToPtrGStrdup(description));
			Gst.IndexEntry ret = raw_ret == IntPtr.Zero ? null : (Gst.IndexEntry) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.IndexEntry), false);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_index_set_group(IntPtr raw, int groupnum);

		public bool SetGroup(int groupnum) {
			bool raw_ret = gst_index_set_group(Handle, groupnum);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gst_index_get_group(IntPtr raw);

		public int Group { 
			get {
				int raw_ret = gst_index_get_group(Handle);
				int ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gst_index_get_certainty(IntPtr raw);

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_index_set_certainty(IntPtr raw, int certainty);

		public Gst.IndexCertainty Certainty { 
			get {
				int raw_ret = gst_index_get_certainty(Handle);
				Gst.IndexCertainty ret = (Gst.IndexCertainty) raw_ret;
				return ret;
			}
			set {
				gst_index_set_certainty(Handle, (int) value);
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gst_index_new_group(IntPtr raw);

		public int NewGroup() {
			int raw_ret = gst_index_new_group(Handle);
			int ret = raw_ret;
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_index_add_object(IntPtr raw, int id, IntPtr key, IntPtr type, IntPtr objekt);

		public Gst.IndexEntry AddObject(int id, string key, Gst.GLib.GType type, Gst.GLib.Object objekt) {
			IntPtr raw_ret = gst_index_add_object(Handle, id, Gst.GLib.Marshaller.StringToPtrGStrdup(key), type.Val, objekt == null ? IntPtr.Zero : objekt.Handle);
			Gst.IndexEntry ret = raw_ret == IntPtr.Zero ? null : (Gst.IndexEntry) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.IndexEntry), false);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_index_get_writer_id(IntPtr raw, IntPtr writer, out int id);

		public bool GetWriterId(Gst.Object writer, out int id) {
			bool raw_ret = gst_index_get_writer_id(Handle, writer == null ? IntPtr.Zero : writer.Handle, out id);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_index_get_assoc_entry(IntPtr raw, int id, int method, int flags, int format, long value);

		public Gst.IndexEntry GetAssocEntry(int id, Gst.IndexLookupMethod method, Gst.AssocFlags flags, Gst.Format format, long value) {
			IntPtr raw_ret = gst_index_get_assoc_entry(Handle, id, (int) method, (int) flags, (int) format, value);
			Gst.IndexEntry ret = raw_ret == IntPtr.Zero ? null : (Gst.IndexEntry) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.IndexEntry), false);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_index_add_format(IntPtr raw, int id, int format);

		public Gst.IndexEntry AddFormat(int id, Gst.Format format) {
			IntPtr raw_ret = gst_index_add_format(Handle, id, (int) format);
			Gst.IndexEntry ret = raw_ret == IntPtr.Zero ? null : (Gst.IndexEntry) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.IndexEntry), false);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_index_add_associationv(IntPtr raw, int id, int flags, int n, Gst.IndexAssociation[] list);

		public Gst.IndexEntry AddAssociation(int id, Gst.AssocFlags flags, int n, Gst.IndexAssociation[] list) {
			IntPtr raw_ret = gst_index_add_associationv(Handle, id, (int) flags, n, list);
			Gst.IndexEntry ret = raw_ret == IntPtr.Zero ? null : (Gst.IndexEntry) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.IndexEntry), false);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_index_get_type();

		public static new Gst.GLib.GType GType { 
			get {
				IntPtr raw_ret = gst_index_get_type();
				Gst.GLib.GType ret = new Gst.GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_index_commit(IntPtr raw, int id);

		public void Commit(int id) {
			gst_index_commit(Handle, id);
		}

#endregion
#region Customized extensions
#line 1 "Index.custom"

public bool IsReadable {
  get {
    return ( ( (uint) Flags) & ( (uint) Gst.IndexFlags.Readable)) != 0;
  }
}

public bool IsWritable {
  get {
    return ( ( (uint) Flags) & ( (uint) Gst.IndexFlags.Writable)) != 0;
  }
}


#endregion
	}
}
