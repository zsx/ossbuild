// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gst {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class Caps : Gst.GLib.Opaque, IEnumerable {

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_caps_from_string(IntPtr str1ng);

		public static Gst.Caps FromString(string str1ng) {
			IntPtr native_str1ng = Gst.GLib.Marshaller.StringToPtrGStrdup (str1ng);
			IntPtr raw_ret = gst_caps_from_string(native_str1ng);
			Gst.Caps ret = raw_ret == IntPtr.Zero ? null : (Gst.Caps) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.Caps), true);
			Gst.GLib.Marshaller.Free (native_str1ng);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_caps_is_equal(IntPtr raw, IntPtr caps2);

		public bool IsEqual(Gst.Caps caps2) {
			bool raw_ret = gst_caps_is_equal(Handle, caps2 == null ? IntPtr.Zero : caps2.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_caps_is_always_compatible(IntPtr raw, IntPtr caps2);

		public bool IsAlwaysCompatible(Gst.Caps caps2) {
			bool raw_ret = gst_caps_is_always_compatible(Handle, caps2 == null ? IntPtr.Zero : caps2.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_caps_union(IntPtr raw, IntPtr caps2);

		public Gst.Caps Union(Gst.Caps caps2) {
			IntPtr raw_ret = gst_caps_union(Handle, caps2 == null ? IntPtr.Zero : caps2.Handle);
			Gst.Caps ret = raw_ret == IntPtr.Zero ? null : (Gst.Caps) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.Caps), true);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_caps_is_any(IntPtr raw);

		public bool IsAny { 
			get {
				bool raw_ret = gst_caps_is_any(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_caps_is_empty(IntPtr raw);

		public bool IsEmpty { 
			get {
				bool raw_ret = gst_caps_is_empty(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_caps_intersect(IntPtr raw, IntPtr caps2);

		public Gst.Caps Intersect(Gst.Caps caps2) {
			IntPtr raw_ret = gst_caps_intersect(Handle, caps2 == null ? IntPtr.Zero : caps2.Handle);
			Gst.Caps ret = raw_ret == IntPtr.Zero ? null : (Gst.Caps) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.Caps), true);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_caps_new_any();

		public static Gst.Caps NewAny() {
			IntPtr raw_ret = gst_caps_new_any();
			Gst.Caps ret = raw_ret == IntPtr.Zero ? null : (Gst.Caps) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.Caps), true);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_caps_copy_nth(IntPtr raw, uint nth);

		public Gst.Caps CopyNth(uint nth) {
			IntPtr raw_ret = gst_caps_copy_nth(Handle, nth);
			Gst.Caps ret = raw_ret == IntPtr.Zero ? null : (Gst.Caps) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.Caps), true);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_caps_is_equal_fixed(IntPtr raw, IntPtr caps2);

		public bool IsEqualFixed(Gst.Caps caps2) {
			bool raw_ret = gst_caps_is_equal_fixed(Handle, caps2 == null ? IntPtr.Zero : caps2.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gst_caps_get_size(IntPtr raw);

		public uint Size { 
			get {
				uint raw_ret = gst_caps_get_size(Handle);
				uint ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_caps_normalize(IntPtr raw);

		public Gst.Caps Normalize() {
			IntPtr raw_ret = gst_caps_normalize(Handle);
			Gst.Caps ret = raw_ret == IntPtr.Zero ? null : (Gst.Caps) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.Caps), true);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_caps_is_subset(IntPtr raw, IntPtr superset);

		public bool IsSubset(Gst.Caps superset) {
			bool raw_ret = gst_caps_is_subset(Handle, superset == null ? IntPtr.Zero : superset.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_caps_subtract(IntPtr raw, IntPtr subtrahend);

		public Gst.Caps Subtract(Gst.Caps subtrahend) {
			IntPtr raw_ret = gst_caps_subtract(Handle, subtrahend == null ? IntPtr.Zero : subtrahend.Handle);
			Gst.Caps ret = raw_ret == IntPtr.Zero ? null : (Gst.Caps) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.Caps), true);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_caps_to_string(IntPtr raw);

		public override string ToString() {
			IntPtr raw_ret = gst_caps_to_string(Handle);
			string ret = Gst.GLib.Marshaller.PtrToStringGFree(raw_ret);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_caps_can_intersect(IntPtr raw, IntPtr caps2);

		public bool CanIntersect(Gst.Caps caps2) {
			bool raw_ret = gst_caps_can_intersect(Handle, caps2 == null ? IntPtr.Zero : caps2.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_caps_get_type();

		public static Gst.GLib.GType GType { 
			get {
				IntPtr raw_ret = gst_caps_get_type();
				Gst.GLib.GType ret = new Gst.GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_caps_is_fixed(IntPtr raw);

		public bool IsFixed { 
			get {
				bool raw_ret = gst_caps_is_fixed(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_caps_copy(IntPtr raw);

		public Gst.Caps Copy() {
			IntPtr raw_ret = gst_caps_copy(Handle);
			Gst.Caps ret = raw_ret == IntPtr.Zero ? null : (Gst.Caps) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.Caps), true);
			return ret;
		}

		public Caps(IntPtr raw) : base(raw) {}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_caps_new_empty();

		public Caps () 
		{
			Raw = gst_caps_new_empty();
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_caps_ref(IntPtr raw);

		protected override void Ref (IntPtr raw)
		{
			if (!Owned) {
				gst_caps_ref (raw);
				Owned = true;
			}
		}

#endregion
#region Customized extensions
#line 1 "Caps.custom"
public static Gst.Caps NewEmpty () {
  return new Gst.Caps ();
}

public Caps (Structure s) : this () {
  Append (s);
}

public Caps (Structure[] s) : this () {
  foreach (Structure o in s)
    Append (o);
}

public Caps (string mediaType, params object[] fields) : this () {
  Append (new Structure (mediaType, fields));
}

[DllImport ("gstreamersharpglue-0.10.dll") ]
extern static uint gstsharp_gst_caps_get_refcount_offset ();

static uint refcount_offset = gstsharp_gst_caps_get_refcount_offset ();
private int Refcount {
  get {
    unsafe {
      int* raw_ptr = (int*) ( ( (byte*) Handle) + refcount_offset);
      return (*raw_ptr);
    }
  }
}

public bool IsWritable {
  get {
    return (Refcount == 1);
  }
}

/* FIXME: This is not optimal! */
public void MakeWritable() {
  if (IsWritable)
    return;

  RemoveStructureReferences ();
  IntPtr copy = gst_caps_copy (Raw);
  Raw = copy;
  /* ^--- Takes a second ref, not good */
  Unref (Raw);
  /* ^--- Sets Owned = false, wrong! */
  Owned = true;
}

private Hashtable structures = new Hashtable ();

private void RemoveStructureReference (Structure s) {
  structures.Remove (s.Handle);
  s.CreateNativeCopy ();
}

private void RemoveStructureReferences () {
  foreach (Structure s in structures.Values) {
    RemoveStructureReference (s);
  }
}

[DllImport ("libgstreamer-0.10.dll") ]
private static extern IntPtr gst_caps_get_structure (IntPtr handle, uint index);

public Structure this [uint index] {
  get {
    if (index >= Size)
      throw new ArgumentOutOfRangeException ();

    IntPtr raw_ptr = gst_caps_get_structure (Handle, (uint) index);

    if (structures.Contains (raw_ptr)) {
      Structure ret = (Gst.Structure) structures[raw_ptr];

      return ret;
    } else {
      Structure ret = new Gst.Structure (raw_ptr);

      ret.FreeNative = false;
      structures.Add (raw_ptr, ret);

      return ret;
    }
  }
}

private class StructureEnumerator : IEnumerator {
  Gst.Caps caps;
  long index;

  public StructureEnumerator (Gst.Caps caps) {
    this.caps = caps;
    index = -1;
  }

  public object Current {
    get {
      if (index >= caps.Size)
        throw new ArgumentOutOfRangeException ();
      if (index == -1)
        throw new ArgumentException ();

      return caps[ (uint) index];
    }
  }

  public bool MoveNext () {
    index += 1;
    return (index < caps.Size);
  }

  public void Reset () {
    index = -1;
  }
}

public IEnumerator GetEnumerator() {
  return new StructureEnumerator (this);
}

[DllImport ("libgstreamer-0.10.dll") ]
static extern void gst_caps_append_structure (IntPtr caps, IntPtr structure);

[DllImport ("libgstreamer-0.10.dll") ]
static extern IntPtr gst_structure_copy (IntPtr raw);

public void Append (Structure s) {
  if (!IsWritable)
    throw new ApplicationException ();

  gst_caps_append_structure (Handle, gst_structure_copy (s.Handle));
}

[DllImport ("libgstreamer-0.10.dll") ]
static extern void gst_caps_append (IntPtr caps, IntPtr caps2);

public void Append (Caps caps) {
  if (!IsWritable)
    throw new ApplicationException ();

  gst_caps_append (Handle, gst_caps_copy (caps.Handle));
}

[DllImport ("libgstreamer-0.10.dll") ]
static extern void gst_caps_merge_structure (IntPtr caps, IntPtr structure);

public void Merge (Structure s) {
  if (!IsWritable)
    throw new ApplicationException ();

  gst_caps_merge_structure (Handle, gst_structure_copy (s.Handle));
}

[DllImport ("libgstreamer-0.10.dll") ]
static extern void gst_caps_merge (IntPtr caps, IntPtr caps2);

public void Merge (Caps caps) {
  if (!IsWritable)
    throw new ApplicationException ();

  /* Removes all structures! */
  if (caps.IsAny) {
    RemoveStructureReferences ();
  }
  gst_caps_merge (Handle, gst_caps_copy (caps.Handle));
}

[DllImport ("libgstreamer-0.10.dll") ]
static extern void gst_caps_remove_structure (IntPtr caps, uint index);

public void RemoveStructure (uint index) {
  if (!IsWritable)
    throw new ApplicationException ();
  if (index >= Size)
    throw new ArgumentOutOfRangeException ();

  if (structures.Contains (this[index].Handle)) {
    RemoveStructureReference (this[index]);
  }

  gst_caps_remove_structure (Handle, index);
}

[DllImport ("libgstreamer-0.10.dll") ]
static extern bool gst_caps_do_simplify (IntPtr caps);

public bool DoSimplify () {
  if (!IsWritable)
    throw new ApplicationException ();

  /* FIXME: This is not optimal but we don't know before
   * which structures will be removed */
  RemoveStructureReferences ();

  return gst_caps_do_simplify (Handle);
}

[DllImport ("libgstreamer-0.10.dll") ]
static extern void gst_caps_truncate (IntPtr caps);

public void Truncate () {
  if (!IsWritable)
    throw new ApplicationException ();

  for (uint i = 1; i < Size; i++)
    RemoveStructureReference (this[i]);

  gst_caps_truncate (Handle);
}

[DllImport ("libgstreamer-0.10.dll") ]
static extern void gst_caps_unref (IntPtr raw);

protected override void Unref (IntPtr raw) {
  RemoveStructureReferences ();
  if (Owned) {
    gst_caps_unref (raw);
    Owned = false;
  }
}

class FinalizerInfo {
  IntPtr handle;

  public FinalizerInfo (IntPtr handle) {
    this.handle = handle;
  }

  public bool Handler () {
    gst_caps_unref (handle);
    return false;
  }
}

~Caps () {
  if (!Owned)
    return;
  RemoveStructureReferences ();

  FinalizerInfo info = new FinalizerInfo (Handle);
  Gst.GLib.Timeout.Add (50, new Gst.GLib.TimeoutHandler (info.Handler));
}

protected override Gst.GLib.Opaque Copy (IntPtr raw) {
  return Gst.GLib.Opaque.GetOpaque (gst_caps_ref (raw), typeof (Caps), true);
}


#endregion
	}
}
