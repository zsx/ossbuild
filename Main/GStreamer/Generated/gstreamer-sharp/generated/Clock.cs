// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gst {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class Clock : Gst.Object {

		public Clock(IntPtr raw) : base(raw) {}

		protected Clock() : base(IntPtr.Zero)
		{
			CreateNativeObject (new string [0], new Gst.GLib.Value [0]);
		}

		[Gst.GLib.Property ("stats")]
		public bool Stats {
			get {
				Gst.GLib.Value val = GetProperty ("stats");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set {
				Gst.GLib.Value val = new Gst.GLib.Value(value);
				SetProperty("stats", val);
				val.Dispose ();
			}
		}

		[Gst.GLib.Property ("timeout")]
		public ulong Timeout {
			get {
				Gst.GLib.Value val = GetProperty ("timeout");
				ulong ret = (ulong) val;
				val.Dispose ();
				return ret;
			}
			set {
				Gst.GLib.Value val = new Gst.GLib.Value(value);
				SetProperty("timeout", val);
				val.Dispose ();
			}
		}

		[Gst.GLib.Property ("window-size")]
		public int WindowSize {
			get {
				Gst.GLib.Value val = GetProperty ("window-size");
				int ret = (int) val;
				val.Dispose ();
				return ret;
			}
			set {
				Gst.GLib.Value val = new Gst.GLib.Value(value);
				SetProperty("window-size", val);
				val.Dispose ();
			}
		}

		[Gst.GLib.Property ("window-threshold")]
		public int WindowThreshold {
			get {
				Gst.GLib.Value val = GetProperty ("window-threshold");
				int ret = (int) val;
				val.Dispose ();
				return ret;
			}
			set {
				Gst.GLib.Value val = new Gst.GLib.Value(value);
				SetProperty("window-threshold", val);
				val.Dispose ();
			}
		}

		[DllImport ("gstreamersharpglue-0.10.dll")]
		extern static uint gstsharp_gst_clock_get_rate_numerator_offset ();

		static uint rate_numerator_offset = gstsharp_gst_clock_get_rate_numerator_offset ();
		protected ulong RateNumerator {
			get {
				unsafe {
					ulong* raw_ptr = (ulong*)(((byte*)Handle) + rate_numerator_offset);
					return (*raw_ptr);
				}
			}
			set {
				unsafe {
					ulong* raw_ptr = (ulong*)(((byte*)Handle) + rate_numerator_offset);
					*raw_ptr = value;
				}
			}
		}

		[DllImport ("gstreamersharpglue-0.10.dll")]
		extern static uint gstsharp_gst_clock_get_rate_denominator_offset ();

		static uint rate_denominator_offset = gstsharp_gst_clock_get_rate_denominator_offset ();
		protected ulong RateDenominator {
			get {
				unsafe {
					ulong* raw_ptr = (ulong*)(((byte*)Handle) + rate_denominator_offset);
					return (*raw_ptr);
				}
			}
			set {
				unsafe {
					ulong* raw_ptr = (ulong*)(((byte*)Handle) + rate_denominator_offset);
					*raw_ptr = value;
				}
			}
		}

		[DllImport ("gstreamersharpglue-0.10.dll")]
		extern static uint gstsharp_gst_clock_get_internal_calibration_offset ();

		static uint internal_calibration_offset = gstsharp_gst_clock_get_internal_calibration_offset ();
		protected ulong InternalCalibration {
			get {
				unsafe {
					ulong* raw_ptr = (ulong*)(((byte*)Handle) + internal_calibration_offset);
					return (*raw_ptr);
				}
			}
			set {
				unsafe {
					ulong* raw_ptr = (ulong*)(((byte*)Handle) + internal_calibration_offset);
					*raw_ptr = value;
				}
			}
		}

		[DllImport ("gstreamersharpglue-0.10.dll")]
		extern static uint gstsharp_gst_clock_get_clockid_offset ();

		static uint clockid_offset = gstsharp_gst_clock_get_clockid_offset ();
		protected Gst.ClockEntry ClockID {
			get {
				unsafe {
					IntPtr* raw_ptr = (IntPtr*)(((byte*)Handle) + clockid_offset);
					return (*raw_ptr) == IntPtr.Zero ? null : (Gst.ClockEntry) Gst.GLib.Opaque.GetOpaque ((*raw_ptr), typeof (Gst.ClockEntry), false);
				}
			}
			set {
				unsafe {
					IntPtr* raw_ptr = (IntPtr*)(((byte*)Handle) + clockid_offset);
					*raw_ptr = value == null ? IntPtr.Zero : value.Handle;
				}
			}
		}

		[DllImport ("gstreamersharpglue-0.10.dll")]
		extern static uint gstsharp_gst_clock_get_external_calibration_offset ();

		static uint external_calibration_offset = gstsharp_gst_clock_get_external_calibration_offset ();
		protected ulong ExternalCalibration {
			get {
				unsafe {
					ulong* raw_ptr = (ulong*)(((byte*)Handle) + external_calibration_offset);
					return (*raw_ptr);
				}
			}
			set {
				unsafe {
					ulong* raw_ptr = (ulong*)(((byte*)Handle) + external_calibration_offset);
					*raw_ptr = value;
				}
			}
		}

		[DllImport ("gstreamersharpglue-0.10.dll")]
		extern static uint gstsharp_gst_clock_get_last_time_offset ();

		static uint last_time_offset = gstsharp_gst_clock_get_last_time_offset ();
		protected ulong LastTime {
			get {
				unsafe {
					ulong* raw_ptr = (ulong*)(((byte*)Handle) + last_time_offset);
					return (*raw_ptr);
				}
			}
			set {
				unsafe {
					ulong* raw_ptr = (ulong*)(((byte*)Handle) + last_time_offset);
					*raw_ptr = value;
				}
			}
		}

		[DllImport ("gstreamersharpglue-0.10.dll")]
		extern static uint gstsharp_gst_clock_get_time_index_offset ();

		static uint time_index_offset = gstsharp_gst_clock_get_time_index_offset ();
		protected int TimeIndex {
			get {
				unsafe {
					int* raw_ptr = (int*)(((byte*)Handle) + time_index_offset);
					return (*raw_ptr);
				}
			}
			set {
				unsafe {
					int* raw_ptr = (int*)(((byte*)Handle) + time_index_offset);
					*raw_ptr = value;
				}
			}
		}

		[DllImport ("gstreamersharpglue-0.10.dll")]
		extern static uint gstsharp_gst_clock_get_filling_offset ();

		static uint filling_offset = gstsharp_gst_clock_get_filling_offset ();
		protected bool Filling {
			get {
				unsafe {
					bool* raw_ptr = (bool*)(((byte*)Handle) + filling_offset);
					return (*raw_ptr);
				}
			}
			set {
				unsafe {
					bool* raw_ptr = (bool*)(((byte*)Handle) + filling_offset);
					*raw_ptr = value;
				}
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern ulong gst_clock_get_resolution(IntPtr raw);

		public ulong Resolution {
			get  {
				ulong raw_ret = gst_clock_get_resolution(Handle);
				ulong ret = raw_ret;
				return ret;
			}
		}

		static ChangeResolutionNativeDelegate ChangeResolution_cb_delegate;
		static ChangeResolutionNativeDelegate ChangeResolutionVMCallback {
			get {
				if (ChangeResolution_cb_delegate == null)
					ChangeResolution_cb_delegate = new ChangeResolutionNativeDelegate (ChangeResolution_cb);
				return ChangeResolution_cb_delegate;
			}
		}

		static void OverrideChangeResolution (Gst.GLib.GType gtype)
		{
			OverrideChangeResolution (gtype, ChangeResolutionVMCallback);
		}

		static void OverrideChangeResolution (Gst.GLib.GType gtype, ChangeResolutionNativeDelegate callback)
		{
			GstClockClass class_iface = GetClassStruct (gtype, false);
			class_iface.ChangeResolution = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate ulong ChangeResolutionNativeDelegate (IntPtr inst, ulong old_resolution, ulong new_resolution);

		static ulong ChangeResolution_cb (IntPtr inst, ulong old_resolution, ulong new_resolution)
		{
			try {
				Clock __obj = Gst.GLib.Object.GetObject (inst, false) as Clock;
				ulong __result = __obj.OnChangeResolution (old_resolution, new_resolution);
				return __result;
			} catch (Exception e) {
				Gst.GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[Gst.GLib.DefaultSignalHandler(Type=typeof(Gst.Clock), ConnectionMethod="OverrideChangeResolution")]
		protected virtual ulong OnChangeResolution (ulong old_resolution, ulong new_resolution)
		{
			return InternalChangeResolution (old_resolution, new_resolution);
		}

		private ulong InternalChangeResolution (ulong old_resolution, ulong new_resolution)
		{
			ChangeResolutionNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).ChangeResolution;
			if (unmanaged == null) return 0;

			ulong __result = unmanaged (this.Handle, old_resolution, new_resolution);
			return __result;
		}

		static GetResolutionNativeDelegate GetResolution_cb_delegate;
		static GetResolutionNativeDelegate GetResolutionVMCallback {
			get {
				if (GetResolution_cb_delegate == null)
					GetResolution_cb_delegate = new GetResolutionNativeDelegate (GetResolution_cb);
				return GetResolution_cb_delegate;
			}
		}

		static void OverrideGetResolution (Gst.GLib.GType gtype)
		{
			OverrideGetResolution (gtype, GetResolutionVMCallback);
		}

		static void OverrideGetResolution (Gst.GLib.GType gtype, GetResolutionNativeDelegate callback)
		{
			GstClockClass class_iface = GetClassStruct (gtype, false);
			class_iface.GetResolution = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate ulong GetResolutionNativeDelegate (IntPtr inst);

		static ulong GetResolution_cb (IntPtr inst)
		{
			try {
				Clock __obj = Gst.GLib.Object.GetObject (inst, false) as Clock;
				ulong __result = __obj.OnGetResolution ();
				return __result;
			} catch (Exception e) {
				Gst.GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[Gst.GLib.DefaultSignalHandler(Type=typeof(Gst.Clock), ConnectionMethod="OverrideGetResolution")]
		protected virtual ulong OnGetResolution ()
		{
			return InternalGetResolution ();
		}

		private ulong InternalGetResolution ()
		{
			GetResolutionNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).GetResolution;
			if (unmanaged == null) return 0;

			ulong __result = unmanaged (this.Handle);
			return __result;
		}

		static GetInternalTimeNativeDelegate GetInternalTime_cb_delegate;
		static GetInternalTimeNativeDelegate GetInternalTimeVMCallback {
			get {
				if (GetInternalTime_cb_delegate == null)
					GetInternalTime_cb_delegate = new GetInternalTimeNativeDelegate (GetInternalTime_cb);
				return GetInternalTime_cb_delegate;
			}
		}

		static void OverrideGetInternalTime (Gst.GLib.GType gtype)
		{
			OverrideGetInternalTime (gtype, GetInternalTimeVMCallback);
		}

		static void OverrideGetInternalTime (Gst.GLib.GType gtype, GetInternalTimeNativeDelegate callback)
		{
			GstClockClass class_iface = GetClassStruct (gtype, false);
			class_iface.GetInternalTime = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate ulong GetInternalTimeNativeDelegate (IntPtr inst);

		static ulong GetInternalTime_cb (IntPtr inst)
		{
			try {
				Clock __obj = Gst.GLib.Object.GetObject (inst, false) as Clock;
				ulong __result = __obj.OnGetInternalTime ();
				return __result;
			} catch (Exception e) {
				Gst.GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[Gst.GLib.DefaultSignalHandler(Type=typeof(Gst.Clock), ConnectionMethod="OverrideGetInternalTime")]
		protected virtual ulong OnGetInternalTime ()
		{
			return InternalGetInternalTime ();
		}

		private ulong InternalGetInternalTime ()
		{
			GetInternalTimeNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).GetInternalTime;
			if (unmanaged == null) return 0;

			ulong __result = unmanaged (this.Handle);
			return __result;
		}

		static WaitAsyncNativeDelegate WaitAsync_cb_delegate;
		static WaitAsyncNativeDelegate WaitAsyncVMCallback {
			get {
				if (WaitAsync_cb_delegate == null)
					WaitAsync_cb_delegate = new WaitAsyncNativeDelegate (WaitAsync_cb);
				return WaitAsync_cb_delegate;
			}
		}

		static void OverrideWaitAsync (Gst.GLib.GType gtype)
		{
			OverrideWaitAsync (gtype, WaitAsyncVMCallback);
		}

		static void OverrideWaitAsync (Gst.GLib.GType gtype, WaitAsyncNativeDelegate callback)
		{
			GstClockClass class_iface = GetClassStruct (gtype, false);
			class_iface.WaitAsync = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate int WaitAsyncNativeDelegate (IntPtr inst, IntPtr entry);

		static int WaitAsync_cb (IntPtr inst, IntPtr entry)
		{
			try {
				Clock __obj = Gst.GLib.Object.GetObject (inst, false) as Clock;
				Gst.ClockReturn __result = __obj.OnWaitAsync (entry == IntPtr.Zero ? null : (Gst.ClockEntry) Gst.GLib.Opaque.GetOpaque (entry, typeof (Gst.ClockEntry), false));
				return (int) __result;
			} catch (Exception e) {
				Gst.GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[Gst.GLib.DefaultSignalHandler(Type=typeof(Gst.Clock), ConnectionMethod="OverrideWaitAsync")]
		protected virtual Gst.ClockReturn OnWaitAsync (Gst.ClockEntry entry)
		{
			return InternalWaitAsync (entry);
		}

		private Gst.ClockReturn InternalWaitAsync (Gst.ClockEntry entry)
		{
			WaitAsyncNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).WaitAsync;
			if (unmanaged == null) return (Gst.ClockReturn) 0;

			int __result = unmanaged (this.Handle, entry == null ? IntPtr.Zero : entry.Handle);
			return (Gst.ClockReturn) __result;
		}

		static UnscheduleNativeDelegate Unschedule_cb_delegate;
		static UnscheduleNativeDelegate UnscheduleVMCallback {
			get {
				if (Unschedule_cb_delegate == null)
					Unschedule_cb_delegate = new UnscheduleNativeDelegate (Unschedule_cb);
				return Unschedule_cb_delegate;
			}
		}

		static void OverrideUnschedule (Gst.GLib.GType gtype)
		{
			OverrideUnschedule (gtype, UnscheduleVMCallback);
		}

		static void OverrideUnschedule (Gst.GLib.GType gtype, UnscheduleNativeDelegate callback)
		{
			GstClockClass class_iface = GetClassStruct (gtype, false);
			class_iface.Unschedule = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void UnscheduleNativeDelegate (IntPtr inst, IntPtr entry);

		static void Unschedule_cb (IntPtr inst, IntPtr entry)
		{
			try {
				Clock __obj = Gst.GLib.Object.GetObject (inst, false) as Clock;
				__obj.OnUnschedule (entry == IntPtr.Zero ? null : (Gst.ClockEntry) Gst.GLib.Opaque.GetOpaque (entry, typeof (Gst.ClockEntry), false));
			} catch (Exception e) {
				Gst.GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[Gst.GLib.DefaultSignalHandler(Type=typeof(Gst.Clock), ConnectionMethod="OverrideUnschedule")]
		protected virtual void OnUnschedule (Gst.ClockEntry entry)
		{
			InternalUnschedule (entry);
		}

		private void InternalUnschedule (Gst.ClockEntry entry)
		{
			UnscheduleNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).Unschedule;
			if (unmanaged == null) return;

			unmanaged (this.Handle, entry == null ? IntPtr.Zero : entry.Handle);
		}

		static WaitJitterNativeDelegate WaitJitter_cb_delegate;
		static WaitJitterNativeDelegate WaitJitterVMCallback {
			get {
				if (WaitJitter_cb_delegate == null)
					WaitJitter_cb_delegate = new WaitJitterNativeDelegate (WaitJitter_cb);
				return WaitJitter_cb_delegate;
			}
		}

		static void OverrideWaitJitter (Gst.GLib.GType gtype)
		{
			OverrideWaitJitter (gtype, WaitJitterVMCallback);
		}

		static void OverrideWaitJitter (Gst.GLib.GType gtype, WaitJitterNativeDelegate callback)
		{
			GstClockClass class_iface = GetClassStruct (gtype, false);
			class_iface.WaitJitter = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate int WaitJitterNativeDelegate (IntPtr inst, IntPtr entry, out long jitter);

		static int WaitJitter_cb (IntPtr inst, IntPtr entry, out long jitter)
		{
			try {
				Clock __obj = Gst.GLib.Object.GetObject (inst, false) as Clock;
				Gst.ClockReturn __result = __obj.OnWaitJitter (entry == IntPtr.Zero ? null : (Gst.ClockEntry) Gst.GLib.Opaque.GetOpaque (entry, typeof (Gst.ClockEntry), false), out jitter);
				return (int) __result;
			} catch (Exception e) {
				Gst.GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[Gst.GLib.DefaultSignalHandler(Type=typeof(Gst.Clock), ConnectionMethod="OverrideWaitJitter")]
		protected virtual Gst.ClockReturn OnWaitJitter (Gst.ClockEntry entry, out long jitter)
		{
			return InternalWaitJitter (entry, out jitter);
		}

		private Gst.ClockReturn InternalWaitJitter (Gst.ClockEntry entry, out long jitter)
		{
			WaitJitterNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).WaitJitter;
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			int __result = unmanaged (this.Handle, entry == null ? IntPtr.Zero : entry.Handle, out jitter);
			return (Gst.ClockReturn) __result;
		}

		[StructLayout (LayoutKind.Sequential)]
		struct GstClockClass {
			public ChangeResolutionNativeDelegate ChangeResolution;
			public GetResolutionNativeDelegate GetResolution;
			public GetInternalTimeNativeDelegate GetInternalTime;
			IntPtr Wait;
			public WaitAsyncNativeDelegate WaitAsync;
			public UnscheduleNativeDelegate Unschedule;
			public WaitJitterNativeDelegate WaitJitter;
			[MarshalAs (UnmanagedType.ByValArray, SizeConst=3)]
			public IntPtr[] GstReserved;
		}

		static uint class_offset = ((Gst.GLib.GType) typeof (Gst.Object)).GetClassSize ();
		static Hashtable class_structs;

		static GstClockClass GetClassStruct (Gst.GLib.GType gtype, bool use_cache)
		{
			if (class_structs == null)
				class_structs = new Hashtable ();

			if (use_cache && class_structs.Contains (gtype))
				return (GstClockClass) class_structs [gtype];
			else {
				IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
				GstClockClass class_struct = (GstClockClass) Marshal.PtrToStructure (class_ptr, typeof (GstClockClass));
				if (use_cache)
					class_structs.Add (gtype, class_struct);
				return class_struct;
			}
		}

		static void OverrideClassStruct (Gst.GLib.GType gtype, GstClockClass class_struct)
		{
			IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
			Marshal.StructureToPtr (class_struct, class_ptr, false);
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern ulong gst_clock_set_resolution(IntPtr raw, ulong resolution);

		public ulong SetResolution(ulong resolution) {
			ulong raw_ret = gst_clock_set_resolution(Handle, resolution);
			ulong ret = raw_ret;
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern ulong gst_clock_get_internal_time(IntPtr raw);

		public ulong InternalTime { 
			get {
				ulong raw_ret = gst_clock_get_internal_time(Handle);
				ulong ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_clock_get_calibration(IntPtr raw, out ulong _internal, out ulong external, out ulong rate_num, out ulong rate_denom);

		public void GetCalibration(out ulong _internal, out ulong external, out ulong rate_num, out ulong rate_denom) {
			gst_clock_get_calibration(Handle, out _internal, out external, out rate_num, out rate_denom);
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern ulong gst_clock_adjust_unlocked(IntPtr raw, ulong _internal);

		protected ulong AdjustUnlocked(ulong _internal) {
			ulong raw_ret = gst_clock_adjust_unlocked(Handle, _internal);
			ulong ret = raw_ret;
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_clock_new_periodic_id(IntPtr raw, ulong start_time, ulong interval);

		public Gst.ClockEntry NewPeriodicID(ulong start_time, ulong interval) {
			IntPtr raw_ret = gst_clock_new_periodic_id(Handle, start_time, interval);
			Gst.ClockEntry ret = raw_ret == IntPtr.Zero ? null : (Gst.ClockEntry) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.ClockEntry), true);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_clock_new_single_shot_id(IntPtr raw, ulong time);

		public Gst.ClockEntry NewSingleShotID(ulong time) {
			IntPtr raw_ret = gst_clock_new_single_shot_id(Handle, time);
			Gst.ClockEntry ret = raw_ret == IntPtr.Zero ? null : (Gst.ClockEntry) Gst.GLib.Opaque.GetOpaque (raw_ret, typeof (Gst.ClockEntry), true);
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern ulong gst_clock_unadjust_unlocked(IntPtr raw, ulong external);

		protected ulong UnadjustUnlocked(ulong external) {
			ulong raw_ret = gst_clock_unadjust_unlocked(Handle, external);
			ulong ret = raw_ret;
			return ret;
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern ulong gst_clock_get_time(IntPtr raw);

		public ulong Time { 
			get {
				ulong raw_ret = gst_clock_get_time(Handle);
				ulong ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gst_clock_set_calibration(IntPtr raw, ulong _internal, ulong external, ulong rate_num, ulong rate_denom);

		public void SetCalibration(ulong _internal, ulong external, ulong rate_num, ulong rate_denom) {
			gst_clock_set_calibration(Handle, _internal, external, rate_num, rate_denom);
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gst_clock_get_type();

		public static new Gst.GLib.GType GType { 
			get {
				IntPtr raw_ret = gst_clock_get_type();
				Gst.GLib.GType ret = new Gst.GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("libgstreamer-0.10.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gst_clock_add_observation(IntPtr raw, ulong slave, ulong master, out double r_squared);

		public bool AddObservation(ulong slave, ulong master, out double r_squared) {
			bool raw_ret = gst_clock_add_observation(Handle, slave, master, out r_squared);
			bool ret = raw_ret;
			return ret;
		}

#endregion
#region Customized extensions
#line 1 "Clock.custom"
public static readonly ulong Second = 1000000000;
public static readonly ulong MSecond = 1000000;
public static readonly ulong USecond = 1000;
public static readonly ulong NSecond = 1;
public static readonly ulong TimeNone = 0xffffffffffffffff;

public static bool TimeIsValid (ulong time) {
  return (time != TimeNone);
}

[DllImport ("gstreamersharpglue-0.10.dll") ]
extern static uint gstsharp_gst_clock_get_entries_changed_offset ();

static uint entries_changed_offset = gstsharp_gst_clock_get_entries_changed_offset ();
private IntPtr EntriesChangedPtr {
  get {
    unsafe {
      IntPtr* raw_ptr = (IntPtr*) ( ( (byte*) Handle) + entries_changed_offset);
      return (*raw_ptr);
    }
  }
}

[DllImport ("libglib-2.0-0.dll") ]
static extern void g_cond_wait (IntPtr cond, IntPtr mutex);
[DllImport ("libglib-2.0-0.dll") ]
static extern bool g_cond_timed_wait (IntPtr cond, IntPtr mutex, ref _TimeVal abs_time);
[DllImport ("libglib-2.0-0.dll") ]
static extern void g_cond_broadcast (IntPtr cond);

public void Wait () {
  g_cond_wait (EntriesChangedPtr, LockPtr);
}

[StructLayout (LayoutKind.Sequential) ]
private struct _TimeVal {
  public IntPtr sec;
  public IntPtr usec;
}

public bool Wait (uint mseconds) {
  _TimeVal tv = new _TimeVal ();
  long sec = mseconds / 1000;
  long usec = 1000 * (mseconds - sec * 1000);
  tv.sec = (IntPtr) (sec);
  tv.usec = (IntPtr) (usec);
  return g_cond_timed_wait (EntriesChangedPtr, LockPtr, ref tv);
}

public bool Wait (TimeSpan timespan) {
  _TimeVal tv = new _TimeVal ();
  long sec = (long) timespan.TotalSeconds;
  long usec = 1000 * ( ( (long) timespan.TotalMilliseconds) - sec * 1000);
  tv.sec = (IntPtr) (sec);
  tv.usec = (IntPtr) (usec);
  return g_cond_timed_wait (EntriesChangedPtr, LockPtr, ref tv);
}

public void Broadcast () {
  g_cond_broadcast (EntriesChangedPtr);
}

[DllImport ("gstreamersharpglue-0.10.dll") ]
extern static uint gstsharp_gst_clock_get_slave_lock_offset ();

static uint slave_lock_offset = gstsharp_gst_clock_get_slave_lock_offset ();
private IntPtr SlaveLockPtr {
  get {
    unsafe {
      IntPtr* raw_ptr = (IntPtr*) ( ( (byte*) Handle) + slave_lock_offset);
      return (*raw_ptr);
    }
  }
}

[DllImport ("libglib-2.0-0.dll") ]
static extern void g_mutex_lock (IntPtr mutex);
[DllImport ("libglib-2.0-0.dll") ]
static extern void g_mutex_unlock (IntPtr mutex);
[DllImport ("libglib-2.0-0.dll") ]
static extern bool g_mutex_trylock (IntPtr mutex);

public void SlaveLock () {
  g_mutex_lock (SlaveLockPtr);
}

public void SlaveUnlock () {
  g_mutex_unlock (SlaveLockPtr);
}

public bool TrySlaveLock () {
  return g_mutex_trylock (SlaveLockPtr);
}

[DllImport ("libgstreamer-0.10.dll") ]
static extern IntPtr gst_clock_get_master (IntPtr raw);
[DllImport ("libgstreamer-0.10.dll") ]
static extern bool gst_clock_set_master (IntPtr raw, IntPtr master);
public Gst.Clock Master {
  get  {
    IntPtr raw_ret = gst_clock_get_master (Handle);
    Gst.Clock ret = Gst.GLib.Object.GetObject (raw_ret, true) as Gst.Clock;
    return ret;
  } set {
    if (!gst_clock_set_master (Handle, value == null ? IntPtr.Zero : value.Handle))
      throw new Exception ();
  }
}

[DllImport ("gstreamersharpglue-0.10.dll") ]
extern static uint gstsharp_gst_clock_get_entries_offset ();

static uint entries_offset = gstsharp_gst_clock_get_entries_offset ();
private IntPtr EntriesPtr {
  get {
    unsafe {
      IntPtr* raw_ptr = (IntPtr*) ( ( (byte*) Handle) + entries_offset);
      return (*raw_ptr);
    }
  }
}

protected Gst.ClockEntry[] Entries {
  get {
    return (Gst.ClockEntry[]) Gst.GLib.Marshaller.ListPtrToArray (EntriesPtr, typeof (Gst.GLib.List), false, false, typeof (Gst.ClockEntry));
  }
}

[DllImport ("gstreamersharpglue-0.10.dll") ]
extern static uint gstsharp_gst_clock_get_times_offset ();

static uint times_offset = gstsharp_gst_clock_get_times_offset ();
private IntPtr TimesPtr {
  get {
    unsafe {
      IntPtr* raw_ptr = (IntPtr*) ( ( (byte*) Handle) + times_offset);
      return (*raw_ptr);
    }
  }
}

protected ulong[] Times {
  get {
    ulong[] ret = new ulong[4 * WindowSize];
    for (int i = 0; i < 4 * WindowSize; i++)
      ret[i] = (ulong) Marshal.ReadInt64 (TimesPtr, 8 * i);
    return ret;
  }
}



#endregion
	}
}
