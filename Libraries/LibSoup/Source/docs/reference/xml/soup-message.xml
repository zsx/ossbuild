<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="SoupMessage">
<refmeta>
<refentrytitle role="top_of_page" id="SoupMessage.top_of_page">SoupMessage</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>LIBSOUP-2.4 Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>SoupMessage</refname>
<refpurpose>An HTTP request and response.</refpurpose>
</refnamediv>

<refsynopsisdiv id="SoupMessage.synopsis" role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>
                    <link linkend="SoupMessage-struct">SoupMessage</link>;

<link linkend="SoupMessage">SoupMessage</link> *       <link linkend="soup-message-new">soup_message_new</link>                    (const <link linkend="char">char</link> *method,
                                                         const <link linkend="char">char</link> *uri_string);
<link linkend="SoupMessage">SoupMessage</link> *       <link linkend="soup-message-new-from-uri">soup_message_new_from_uri</link>           (const <link linkend="char">char</link> *method,
                                                         <link linkend="SoupURI">SoupURI</link> *uri);
<link linkend="void">void</link>                <link linkend="soup-message-set-request">soup_message_set_request</link>            (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *content_type,
                                                         <link linkend="SoupMemoryUse">SoupMemoryUse</link> req_use,
                                                         const <link linkend="char">char</link> *req_body,
                                                         <link linkend="gsize">gsize</link> req_length);
<link linkend="void">void</link>                <link linkend="soup-message-set-response">soup_message_set_response</link>           (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *content_type,
                                                         <link linkend="SoupMemoryUse">SoupMemoryUse</link> resp_use,
                                                         const <link linkend="char">char</link> *resp_body,
                                                         <link linkend="gsize">gsize</link> resp_length);

enum                <link linkend="SoupHTTPVersion">SoupHTTPVersion</link>;
<link linkend="void">void</link>                <link linkend="soup-message-set-http-version">soup_message_set_http_version</link>       (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupHTTPVersion">SoupHTTPVersion</link> version);
<link linkend="SoupHTTPVersion">SoupHTTPVersion</link>     <link linkend="soup-message-get-http-version">soup_message_get_http_version</link>       (<link linkend="SoupMessage">SoupMessage</link> *msg);
<link linkend="SoupURI">SoupURI</link> *           <link linkend="soup-message-get-uri">soup_message_get_uri</link>                (<link linkend="SoupMessage">SoupMessage</link> *msg);
<link linkend="void">void</link>                <link linkend="soup-message-set-uri">soup_message_set_uri</link>                (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupURI">SoupURI</link> *uri);
<link linkend="SoupAddress">SoupAddress</link> *       <link linkend="soup-message-get-address">soup_message_get_address</link>            (<link linkend="SoupMessage">SoupMessage</link> *msg);

<link linkend="void">void</link>                <link linkend="soup-message-set-status">soup_message_set_status</link>             (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="guint">guint</link> status_code);
<link linkend="void">void</link>                <link linkend="soup-message-set-status-full">soup_message_set_status_full</link>        (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="guint">guint</link> status_code,
                                                         const <link linkend="char">char</link> *reason_phrase);
<link linkend="gboolean">gboolean</link>            <link linkend="soup-message-is-keepalive">soup_message_is_keepalive</link>           (<link linkend="SoupMessage">SoupMessage</link> *msg);

<link linkend="guint">guint</link>               <link linkend="soup-message-add-header-handler">soup_message_add_header_handler</link>     (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *signal,
                                                         const <link linkend="char">char</link> *header,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="guint">guint</link>               <link linkend="soup-message-add-status-code-handler">soup_message_add_status_code_handler</link>
                                                        (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *signal,
                                                         <link linkend="guint">guint</link> status_code,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data);

enum                <link linkend="SoupMessageFlags">SoupMessageFlags</link>;
<link linkend="void">void</link>                <link linkend="soup-message-set-flags">soup_message_set_flags</link>              (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupMessageFlags">SoupMessageFlags</link> flags);
<link linkend="SoupMessageFlags">SoupMessageFlags</link>    <link linkend="soup-message-get-flags">soup_message_get_flags</link>              (<link linkend="SoupMessage">SoupMessage</link> *msg);
<link linkend="SoupBuffer">SoupBuffer</link> *        (<link linkend="SoupChunkAllocator">*SoupChunkAllocator</link>)               (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="gsize">gsize</link> max_len,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="void">void</link>                <link linkend="soup-message-set-chunk-allocator">soup_message_set_chunk_allocator</link>    (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupChunkAllocator">SoupChunkAllocator</link> allocator,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy_notify);

#define             <link linkend="SOUP-MESSAGE-METHOD--CAPS">SOUP_MESSAGE_METHOD</link>
#define             <link linkend="SOUP-MESSAGE-URI--CAPS">SOUP_MESSAGE_URI</link>
#define             <link linkend="SOUP-MESSAGE-HTTP-VERSION--CAPS">SOUP_MESSAGE_HTTP_VERSION</link>
#define             <link linkend="SOUP-MESSAGE-FLAGS--CAPS">SOUP_MESSAGE_FLAGS</link>
#define             <link linkend="SOUP-MESSAGE-STATUS-CODE--CAPS">SOUP_MESSAGE_STATUS_CODE</link>
#define             <link linkend="SOUP-MESSAGE-REASON-PHRASE--CAPS">SOUP_MESSAGE_REASON_PHRASE</link>
#define             <link linkend="SOUP-MESSAGE-SERVER-SIDE--CAPS">SOUP_MESSAGE_SERVER_SIDE</link>
</synopsis>
</refsynopsisdiv>

<refsect1 id="SoupMessage.object-hierarchy" role="object_hierarchy">
<title role="object_hierarchy.title">Object Hierarchy</title>
<synopsis>
  <link linkend="GObject">GObject</link>
   +----SoupMessage
</synopsis>
</refsect1>





<refsect1 id="SoupMessage.properties" role="properties">
<title role="properties.title">Properties</title>
<synopsis>
  &quot;<link linkend="SoupMessage--flags">flags</link>&quot;                    <link linkend="SoupMessageFlags">SoupMessageFlags</link>      : Read / Write
  &quot;<link linkend="SoupMessage--http-version">http-version</link>&quot;             <link linkend="SoupHTTPVersion">SoupHTTPVersion</link>       : Read / Write
  &quot;<link linkend="SoupMessage--method">method</link>&quot;                   <link linkend="gchar">gchar</link>*                : Read / Write
  &quot;<link linkend="SoupMessage--reason-phrase">reason-phrase</link>&quot;            <link linkend="gchar">gchar</link>*                : Read / Write
  &quot;<link linkend="SoupMessage--server-side">server-side</link>&quot;              <link linkend="gboolean">gboolean</link>              : Read / Write / Construct Only
  &quot;<link linkend="SoupMessage--status-code">status-code</link>&quot;              <link linkend="guint">guint</link>                 : Read / Write
  &quot;<link linkend="SoupMessage--uri">uri</link>&quot;                      <link linkend="SoupURI">SoupURI</link>*              : Read / Write
</synopsis>
</refsect1>

<refsect1 id="SoupMessage.signals" role="signal_proto">
<title role="signal_proto.title">Signals</title>
<synopsis>
  &quot;<link linkend="SoupMessage-finished">finished</link>&quot;                                       : Run First
  &quot;<link linkend="SoupMessage-got-body">got-body</link>&quot;                                       : Run First
  &quot;<link linkend="SoupMessage-got-chunk">got-chunk</link>&quot;                                      : Run First
  &quot;<link linkend="SoupMessage-got-headers">got-headers</link>&quot;                                    : Run First
  &quot;<link linkend="SoupMessage-got-informational">got-informational</link>&quot;                              : Run First
  &quot;<link linkend="SoupMessage-restarted">restarted</link>&quot;                                      : Run First
  &quot;<link linkend="SoupMessage-wrote-body">wrote-body</link>&quot;                                     : Run First
  &quot;<link linkend="SoupMessage-wrote-body-data">wrote-body-data</link>&quot;                                : Run First
  &quot;<link linkend="SoupMessage-wrote-chunk">wrote-chunk</link>&quot;                                    : Run First
  &quot;<link linkend="SoupMessage-wrote-headers">wrote-headers</link>&quot;                                  : Run First
  &quot;<link linkend="SoupMessage-wrote-informational">wrote-informational</link>&quot;                            : Run First
</synopsis>
</refsect1>


<refsect1 id="SoupMessage.description" role="desc">
<title role="desc.title">Description</title>
<para>
A <link linkend="SoupMessage"><type>SoupMessage</type></link> represents an HTTP message that is being sent or
received.
</para>
<para>
For client-side usage, you would create a <link linkend="SoupMessage"><type>SoupMessage</type></link> with
<link linkend="soup-message-new"><function>soup_message_new()</function></link> or <link linkend="soup-message-new-from-uri"><function>soup_message_new_from_uri()</function></link>, set up its
fields appropriate, and send it via a <link linkend="SoupSession"><type>SoupSession</type></link>.
</para>
<para>
For server-side usage, <link linkend="SoupServer"><type>SoupServer</type></link> will create <link linkend="SoupMessage"><type>SoupMessage</type></link><!--
-->s automatically for incoming requests, which your application
will receive via handlers.
</para>
<para>
Note that libsoup's terminology here does not quite match the HTTP
specification: in RFC 2616, an "HTTP-message" is
<emphasis>either</emphasis> a Request, <emphasis>or</emphasis> a
Response. In libsoup, a <link linkend="SoupMessage"><type>SoupMessage</type></link> combines both the request and
the response.</para>
<para>
</para>
</refsect1>

<refsect1 id="SoupMessage.details" role="details">
<title role="details.title">Details</title>
<refsect2 id="SoupMessage-struct" role="struct">
<title>SoupMessage</title>
<indexterm zone="SoupMessage-struct"><primary sortas="SoupMessage">SoupMessage</primary></indexterm><programlisting>typedef struct {
	const char         *method;

	guint               status_code;
	char               *reason_phrase;

	SoupMessageBody    *request_body;
	SoupMessageHeaders *request_headers;

	SoupMessageBody    *response_body;
	SoupMessageHeaders *response_headers;
} SoupMessage;
</programlisting>
<para>
Represents an HTTP message being sent or received.
</para>
<para>
<parameter>status_code</parameter> will normally be a <link linkend="SoupKnownStatusCode"><type>SoupKnownStatusCode</type></link>, eg,
<link linkend="SOUP-STATUS-OK--CAPS"><literal>SOUP_STATUS_OK</literal></link>, though of course it might actually be an unknown
status code. <parameter>reason_phrase</parameter> is the actual text returned from the
server, which may or may not correspond to the "standard"
description of <parameter>status_code</parameter>. At any rate, it is almost certainly
not localized, and not very descriptive even if it is in the user's
language; you should not use <parameter>reason_phrase</parameter> in user-visible
messages. Rather, you should look at <parameter>status_code</parameter>, and determine an
end-user-appropriate message based on that and on what you were
trying to do.
</para>
<para>
As described in the <link linkend="SoupMessageBody"><type>SoupMessageBody</type></link> documentation, the
<parameter>request_body</parameter> and <parameter>response_body</parameter> <link linkend="data"><literal>data</literal></link> fields will not necessarily
be filled in at all times. When they are filled in, they will be
terminated with a '\0' byte (which is not included in the <link linkend="length"><literal>length</literal></link>),
so you can use them as ordinary C strings (assuming that you know
that the body doesn't have any other '\0' bytes).
</para>
<para>
For a client-side <link linkend="SoupMessage"><type>SoupMessage</type></link>, <parameter>request_body</parameter>'s <link linkend="data"><literal>data</literal></link> is usually
filled in right before libsoup writes the request to the network,
but you should not count on this; use <link linkend="soup-message-body-flatten"><function>soup_message_body_flatten()</function></link>
if you want to ensure that <link linkend="data"><literal>data</literal></link> is filled in. <parameter>response_body</parameter>'s
<link linkend="data"><literal>data</literal></link> will be filled in before <link linkend="SoupMessage-finished"><type>"finished"</type></link> is emitted.
</para>
<para>
For a server-side <link linkend="SoupMessage"><type>SoupMessage</type></link>, <parameter>request_body</parameter>'s <link linkend="data"><literal>data</literal></link> will be
filled in before <link linkend="SoupMessage-got-body"><type>"got_body"</type></link> is emitted.
</para>
<para>
To prevent the <link linkend="data"><literal>data</literal></link> field from being filled in at all (eg, if you
are handling the data from a <link linkend="SoupMessage-got-chunk"><type>"got_chunk"</type></link>, and so don't
need to see it all at the end), call
<link linkend="soup-message-body-set-accumulate"><function>soup_message_body_set_accumulate()</function></link> on <parameter>response_body</parameter> or
<parameter>request_body</parameter> as appropriate, passing <link linkend="FALSE--CAPS"><literal>FALSE</literal></link>.</para>
<para>
</para><variablelist role="struct">
<varlistentry>
<term>const&#160;<link linkend="char">char</link>&#160;*<structfield>method</structfield>;</term>
<listitem><simpara> the HTTP method
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="guint">guint</link>&#160;<structfield>status_code</structfield>;</term>
<listitem><simpara> the HTTP status code
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="char">char</link>&#160;*<structfield>reason_phrase</structfield>;</term>
<listitem><simpara> the status phrase associated with <parameter>status_code</parameter>
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="SoupMessageBody">SoupMessageBody</link>&#160;*<structfield>request_body</structfield>;</term>
<listitem><simpara> the request body
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="SoupMessageHeaders">SoupMessageHeaders</link>&#160;*<structfield>request_headers</structfield>;</term>
<listitem><simpara> the request headers
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="SoupMessageBody">SoupMessageBody</link>&#160;*<structfield>response_body</structfield>;</term>
<listitem><simpara> the response body
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="SoupMessageHeaders">SoupMessageHeaders</link>&#160;*<structfield>response_headers</structfield>;</term>
<listitem><simpara> the response headers
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-new" role="function">
<title>soup_message_new ()</title>
<indexterm zone="soup-message-new"><primary sortas="soup_message_new">soup_message_new</primary></indexterm><programlisting><link linkend="SoupMessage">SoupMessage</link> *       soup_message_new                    (const <link linkend="char">char</link> *method,
                                                         const <link linkend="char">char</link> *uri_string);</programlisting>
<para>
Creates a new empty <link linkend="SoupMessage"><type>SoupMessage</type></link>, which will connect to <parameter>uri</parameter></para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>method</parameter>&#160;:</term>
<listitem><simpara> the HTTP method for the created request
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>uri_string</parameter>&#160;:</term>
<listitem><simpara> the destination endpoint (as a string)
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the new <link linkend="SoupMessage"><type>SoupMessage</type></link> (or <link linkend="NULL--CAPS"><literal>NULL</literal></link> if <parameter>uri</parameter> could not
be parsed).
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-new-from-uri" role="function">
<title>soup_message_new_from_uri ()</title>
<indexterm zone="soup-message-new-from-uri"><primary sortas="soup_message_new_from_uri">soup_message_new_from_uri</primary></indexterm><programlisting><link linkend="SoupMessage">SoupMessage</link> *       soup_message_new_from_uri           (const <link linkend="char">char</link> *method,
                                                         <link linkend="SoupURI">SoupURI</link> *uri);</programlisting>
<para>
Creates a new empty <link linkend="SoupMessage"><type>SoupMessage</type></link>, which will connect to <parameter>uri</parameter></para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>method</parameter>&#160;:</term>
<listitem><simpara> the HTTP method for the created request
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>uri</parameter>&#160;:</term>
<listitem><simpara> the destination endpoint (as a <link linkend="SoupURI"><type>SoupURI</type></link>)
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the new <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-set-request" role="function">
<title>soup_message_set_request ()</title>
<indexterm zone="soup-message-set-request"><primary sortas="soup_message_set_request">soup_message_set_request</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_request            (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *content_type,
                                                         <link linkend="SoupMemoryUse">SoupMemoryUse</link> req_use,
                                                         const <link linkend="char">char</link> *req_body,
                                                         <link linkend="gsize">gsize</link> req_length);</programlisting>
<para>
Convenience function to set the request body of a <link linkend="SoupMessage"><type>SoupMessage</type></link>. If
<parameter>content_type</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>, the request body must be empty as well.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>content_type</parameter>&#160;:</term>
<listitem><simpara> MIME Content-Type of the body
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>req_use</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMemoryUse"><type>SoupMemoryUse</type></link> describing how to handle <parameter>req_body</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>req_body</parameter>&#160;:</term>
<listitem><simpara> a data buffer containing the body of the message request.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>req_length</parameter>&#160;:</term>
<listitem><simpara> the byte length of <parameter>req_body</parameter>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-set-response" role="function">
<title>soup_message_set_response ()</title>
<indexterm zone="soup-message-set-response"><primary sortas="soup_message_set_response">soup_message_set_response</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_response           (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *content_type,
                                                         <link linkend="SoupMemoryUse">SoupMemoryUse</link> resp_use,
                                                         const <link linkend="char">char</link> *resp_body,
                                                         <link linkend="gsize">gsize</link> resp_length);</programlisting>
<para>
Convenience function to set the response body of a <link linkend="SoupMessage"><type>SoupMessage</type></link>. If
<parameter>content_type</parameter> is <link linkend="NULL--CAPS"><literal>NULL</literal></link>, the response body must be empty as well.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>content_type</parameter>&#160;:</term>
<listitem><simpara> MIME Content-Type of the body
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>resp_use</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMemoryUse"><type>SoupMemoryUse</type></link> describing how to handle <parameter>resp_body</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>resp_body</parameter>&#160;:</term>
<listitem><simpara> a data buffer containing the body of the message response.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>resp_length</parameter>&#160;:</term>
<listitem><simpara> the byte length of <parameter>resp_body</parameter>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="SoupHTTPVersion" role="enum">
<title>enum SoupHTTPVersion</title>
<indexterm zone="SoupHTTPVersion"><primary sortas="SoupHTTPVersion">SoupHTTPVersion</primary></indexterm><programlisting>typedef enum {
	SOUP_HTTP_1_0 = 0,
	SOUP_HTTP_1_1 = 1
} SoupHTTPVersion;
</programlisting>
<para>
Indicates the HTTP protocol version being used.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="SOUP-HTTP-1-0--CAPS" role="constant">
<term><literal>SOUP_HTTP_1_0</literal></term>
<listitem><simpara> HTTP 1.0 (RFC 1945)
</simpara></listitem>
</varlistentry>
<varlistentry id="SOUP-HTTP-1-1--CAPS" role="constant">
<term><literal>SOUP_HTTP_1_1</literal></term>
<listitem><simpara> HTTP 1.1 (RFC 2616)
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-set-http-version" role="function">
<title>soup_message_set_http_version ()</title>
<indexterm zone="soup-message-set-http-version"><primary sortas="soup_message_set_http_version">soup_message_set_http_version</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_http_version       (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupHTTPVersion">SoupHTTPVersion</link> version);</programlisting>
<para>
Sets the HTTP version on <parameter>msg</parameter>. The default version is
<link linkend="SOUP-HTTP-1-1--CAPS"><literal>SOUP_HTTP_1_1</literal></link>. Setting it to <link linkend="SOUP-HTTP-1-0--CAPS"><literal>SOUP_HTTP_1_0</literal></link> will prevent certain
functionality from being used.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>version</parameter>&#160;:</term>
<listitem><simpara> the HTTP version
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-get-http-version" role="function">
<title>soup_message_get_http_version ()</title>
<indexterm zone="soup-message-get-http-version"><primary sortas="soup_message_get_http_version">soup_message_get_http_version</primary></indexterm><programlisting><link linkend="SoupHTTPVersion">SoupHTTPVersion</link>     soup_message_get_http_version       (<link linkend="SoupMessage">SoupMessage</link> *msg);</programlisting>
<para>
Gets the HTTP version of <parameter>msg</parameter>. This is the minimum of the
version from the request and the version from the response.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the HTTP version
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-get-uri" role="function">
<title>soup_message_get_uri ()</title>
<indexterm zone="soup-message-get-uri"><primary sortas="soup_message_get_uri">soup_message_get_uri</primary></indexterm><programlisting><link linkend="SoupURI">SoupURI</link> *           soup_message_get_uri                (<link linkend="SoupMessage">SoupMessage</link> *msg);</programlisting>
<para>
Gets <parameter>msg</parameter>'s URI</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the URI <parameter>msg</parameter> is targeted for.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-set-uri" role="function">
<title>soup_message_set_uri ()</title>
<indexterm zone="soup-message-set-uri"><primary sortas="soup_message_set_uri">soup_message_set_uri</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_uri                (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupURI">SoupURI</link> *uri);</programlisting>
<para>
Sets <parameter>msg</parameter>'s URI to <parameter>uri</parameter>. If <parameter>msg</parameter> has already been sent and you want
to re-send it with the new URI, you need to call
<link linkend="soup-session-requeue-message"><function>soup_session_requeue_message()</function></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>uri</parameter>&#160;:</term>
<listitem><simpara> the new <link linkend="SoupURI"><type>SoupURI</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-get-address" role="function" condition="since:2.26">
<title>soup_message_get_address ()</title>
<indexterm zone="soup-message-get-address" role="2.26"><primary sortas="soup_message_get_address">soup_message_get_address</primary></indexterm><programlisting><link linkend="SoupAddress">SoupAddress</link> *       soup_message_get_address            (<link linkend="SoupMessage">SoupMessage</link> *msg);</programlisting>
<para>
Gets the address <parameter>msg</parameter>'s URI points to. After first setting the
URI on a message, this will be unresolved, although the message's
session will resolve it before sending the message.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the address <parameter>msg</parameter>'s URI points to

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since 2.26</para></refsect2>
<refsect2 id="soup-message-set-status" role="function">
<title>soup_message_set_status ()</title>
<indexterm zone="soup-message-set-status"><primary sortas="soup_message_set_status">soup_message_set_status</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_status             (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="guint">guint</link> status_code);</programlisting>
<para>
Sets <parameter>msg</parameter>'s status code to <parameter>status_code</parameter>. If <parameter>status_code</parameter> is a
known value, it will also set <parameter>msg</parameter>'s reason_phrase.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>status_code</parameter>&#160;:</term>
<listitem><simpara> an HTTP status code
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-set-status-full" role="function">
<title>soup_message_set_status_full ()</title>
<indexterm zone="soup-message-set-status-full"><primary sortas="soup_message_set_status_full">soup_message_set_status_full</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_status_full        (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="guint">guint</link> status_code,
                                                         const <link linkend="char">char</link> *reason_phrase);</programlisting>
<para>
Sets <parameter>msg</parameter>'s status code and reason phrase.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>status_code</parameter>&#160;:</term>
<listitem><simpara> an HTTP status code
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>reason_phrase</parameter>&#160;:</term>
<listitem><simpara> a description of the status
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-is-keepalive" role="function">
<title>soup_message_is_keepalive ()</title>
<indexterm zone="soup-message-is-keepalive"><primary sortas="soup_message_is_keepalive">soup_message_is_keepalive</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            soup_message_is_keepalive           (<link linkend="SoupMessage">SoupMessage</link> *msg);</programlisting>
<para>
Determines whether or not <parameter>msg</parameter>'s connection can be kept alive for
further requests after processing <parameter>msg</parameter>, based on the HTTP version,
Connection header, etc.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> <link linkend="TRUE--CAPS"><literal>TRUE</literal></link> or <link linkend="FALSE--CAPS"><literal>FALSE</literal></link>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-add-header-handler" role="function">
<title>soup_message_add_header_handler ()</title>
<indexterm zone="soup-message-add-header-handler"><primary sortas="soup_message_add_header_handler">soup_message_add_header_handler</primary></indexterm><programlisting><link linkend="guint">guint</link>               soup_message_add_header_handler     (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *signal,
                                                         const <link linkend="char">char</link> *header,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Adds a signal handler to <parameter>msg</parameter> for <parameter>signal</parameter>, as with
<link linkend="g-signal-connect"><function>g_signal_connect()</function></link>, but with two differences: the <parameter>callback</parameter> will
only be run if <parameter>msg</parameter> has a header named <parameter>header</parameter>, and it will only be
run if no earlier handler cancelled or requeued the message.
</para>
<para>
If <parameter>signal</parameter> is one of the "got" signals (eg, "got_headers"), or
"finished" or "restarted", then <parameter>header</parameter> is matched against the
incoming message headers (that is, the <link linkend="request-headers"><type>request_headers</type></link> for a
client <link linkend="SoupMessage"><type>SoupMessage</type></link>, or the <link linkend="response-headers"><type>response_headers</type></link> for a server
<link linkend="SoupMessage"><type>SoupMessage</type></link>). If <parameter>signal</parameter> is one of the "wrote" signals, then
<parameter>header</parameter> is matched against the outgoing message headers.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal</parameter>&#160;:</term>
<listitem><simpara> signal to connect the handler to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>header</parameter>&#160;:</term>
<listitem><simpara> HTTP response header to match against
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> the header handler
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> data to pass to <parameter>handler_cb</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the handler ID from <link linkend="g-signal-connect"><function>g_signal_connect()</function></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-add-status-code-handler" role="function">
<title>soup_message_add_status_code_handler ()</title>
<indexterm zone="soup-message-add-status-code-handler"><primary sortas="soup_message_add_status_code_handler">soup_message_add_status_code_handler</primary></indexterm><programlisting><link linkend="guint">guint</link>               soup_message_add_status_code_handler
                                                        (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *signal,
                                                         <link linkend="guint">guint</link> status_code,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Adds a signal handler to <parameter>msg</parameter> for <parameter>signal</parameter>, as with
<link linkend="g-signal-connect"><function>g_signal_connect()</function></link> but with two differences: the <parameter>callback</parameter> will
only be run if <parameter>msg</parameter> has the status <parameter>status_code</parameter>, and it will only
be run if no earlier handler cancelled or requeued the message.
</para>
<para>
<parameter>signal</parameter> must be a signal that will be emitted after <parameter>msg</parameter>'s status
is set. For a client <link linkend="SoupMessage"><type>SoupMessage</type></link>, this means it can't be a "wrote"
signal. For a server <link linkend="SoupMessage"><type>SoupMessage</type></link>, this means it can't be a "got"
signal.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal</parameter>&#160;:</term>
<listitem><simpara> signal to connect the handler to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>status_code</parameter>&#160;:</term>
<listitem><simpara> status code to match against
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&#160;:</term>
<listitem><simpara> the header handler
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> data to pass to <parameter>handler_cb</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the handler ID from <link linkend="g-signal-connect"><function>g_signal_connect()</function></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="SoupMessageFlags" role="enum">
<title>enum SoupMessageFlags</title>
<indexterm zone="SoupMessageFlags"><primary sortas="SoupMessageFlags">SoupMessageFlags</primary></indexterm><programlisting>typedef enum {
#ifndef LIBSOUP_DISABLE_DEPRECATED
	SOUP_MESSAGE_OVERWRITE_CHUNKS = (1 &lt;&lt; 3),
#endif
	SOUP_MESSAGE_NO_REDIRECT      = (1 &lt;&lt; 1)
} SoupMessageFlags;
</programlisting>
<para>
Various flags that can be set on a <link linkend="SoupMessage"><type>SoupMessage</type></link> to alter its
behavior.</para>
<para>
</para><variablelist role="enum">
<varlistentry id="SOUP-MESSAGE-OVERWRITE-CHUNKS--CAPS" role="constant">
<term><literal>SOUP_MESSAGE_OVERWRITE_CHUNKS</literal></term>
<listitem><simpara> Deprecated: equivalent to calling
<link linkend="soup-message-body-set-accumulate"><function>soup_message_body_set_accumulate()</function></link> on the incoming message body
(ie, <link linkend="response-body"><literal>response_body</literal></link> for a client-side request), passing <link linkend="FALSE--CAPS"><literal>FALSE</literal></link>.
</simpara></listitem>
</varlistentry>
<varlistentry id="SOUP-MESSAGE-NO-REDIRECT--CAPS" role="constant">
<term><literal>SOUP_MESSAGE_NO_REDIRECT</literal></term>
<listitem><simpara> The session should not follow redirect
(3xx) responses received by this message.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-set-flags" role="function">
<title>soup_message_set_flags ()</title>
<indexterm zone="soup-message-set-flags"><primary sortas="soup_message_set_flags">soup_message_set_flags</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_flags              (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupMessageFlags">SoupMessageFlags</link> flags);</programlisting>
<para>
Sets the specified flags on <parameter>msg</parameter>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>flags</parameter>&#160;:</term>
<listitem><simpara> a set of <link linkend="SoupMessageFlags"><type>SoupMessageFlags</type></link> values
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-get-flags" role="function">
<title>soup_message_get_flags ()</title>
<indexterm zone="soup-message-get-flags"><primary sortas="soup_message_get_flags">soup_message_get_flags</primary></indexterm><programlisting><link linkend="SoupMessageFlags">SoupMessageFlags</link>    soup_message_get_flags              (<link linkend="SoupMessage">SoupMessage</link> *msg);</programlisting>
<para>
Gets the flags on <parameter>msg</parameter></para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the flags
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="SoupChunkAllocator" role="function">
<title>SoupChunkAllocator ()</title>
<indexterm zone="SoupChunkAllocator"><primary sortas="SoupChunkAllocator">SoupChunkAllocator</primary></indexterm><programlisting><link linkend="SoupBuffer">SoupBuffer</link> *        (*SoupChunkAllocator)               (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="gsize">gsize</link> max_len,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
The prototype for a chunk allocation callback. This should allocate
a new <link linkend="SoupBuffer"><type>SoupBuffer</type></link> and return it for the I/O layer to read message
body data off the network into.
</para>
<para>
If <parameter>max_len</parameter> is non-0, it indicates the maximum number of bytes that
could be read, based on what is known about the message size. Note
that this might be a very large number, and you should not simply
try to allocate that many bytes blindly. If <parameter>max_len</parameter> is 0, that
means that libsoup does not know how many bytes remain to be read,
and the allocator should return a buffer of a size that it finds
convenient.
</para>
<para>
If the allocator returns <link linkend="NULL--CAPS"><literal>NULL</literal></link>, the message will be paused. It is
up to the application to make sure that it gets unpaused when it
becomes possible to allocate a new buffer.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the <link linkend="SoupMessage"><type>SoupMessage</type></link> the chunk is being allocated for
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>max_len</parameter>&#160;:</term>
<listitem><simpara> the maximum length that will be read, or 0.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> the data passed to <link linkend="soup-message-set-chunk-allocator"><function>soup_message_set_chunk_allocator()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&#160;:</term><listitem><simpara> the new buffer (or <link linkend="NULL--CAPS"><literal>NULL</literal></link>)
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="soup-message-set-chunk-allocator" role="function">
<title>soup_message_set_chunk_allocator ()</title>
<indexterm zone="soup-message-set-chunk-allocator"><primary sortas="soup_message_set_chunk_allocator">soup_message_set_chunk_allocator</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_chunk_allocator    (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupChunkAllocator">SoupChunkAllocator</link> allocator,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy_notify);</programlisting>
<para>
Sets an alternate chunk-allocation function to use when reading
<parameter>msg</parameter>'s body. Every time data is available to read, libsoup will
call <parameter>allocator</parameter>, which should return a <link linkend="SoupBuffer"><type>SoupBuffer</type></link>. (See
<link linkend="SoupChunkAllocator"><type>SoupChunkAllocator</type></link> for additional details.) Libsoup will then read
data from the network into that buffer, and update the buffer's
<link linkend="length"><literal>length</literal></link> to indicate how much data it read.
</para>
<para>
Generally, a custom chunk allocator would be used in conjunction
with <link linkend="soup-message-body-set-accumulate"><function>soup_message_body_set_accumulate()</function></link> <link linkend="FALSE--CAPS"><literal>FALSE</literal></link> and
<link linkend="SoupMessage-got-chunk"><type>"got_chunk"</type></link>, as part of a strategy to avoid unnecessary
copying of data. However, you cannot assume that every call to the
allocator will be followed by a call to your <link linkend="got-chunk"><literal>got_chunk</literal></link> handler; if
an I/O error occurs, then the buffer will be unreffed without ever
having been used. If your buffer-allocation strategy requires
special cleanup, use <link linkend="soup-buffer-new-with-owner"><function>soup_buffer_new_with_owner()</function></link> rather than doing
the cleanup from the <link linkend="got-chunk"><literal>got_chunk</literal></link> handler.
</para>
<para>
The other thing to remember when using non-accumulating message
bodies is that the buffer passed to the <link linkend="got-chunk"><literal>got_chunk</literal></link> handler will be
unreffed after the handler returns, just as it would be in the
non-custom-allocated case. If you want to hand the chunk data off
to some other part of your program to use later, you'll need to ref
the <link linkend="SoupBuffer"><type>SoupBuffer</type></link> (or its owner, in the <link linkend="soup-buffer-new-with-owner"><function>soup_buffer_new_with_owner()</function></link>
case) to ensure that the data remains valid.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>allocator</parameter>&#160;:</term>
<listitem><simpara> the chunk allocator callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara> data to pass to <parameter>allocator</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy_notify</parameter>&#160;:</term>
<listitem><simpara> destroy notifier to free <parameter>user_data</parameter> when <parameter>msg</parameter> is
destroyed
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2 id="SOUP-MESSAGE-METHOD--CAPS" role="macro">
<title>SOUP_MESSAGE_METHOD</title>
<indexterm zone="SOUP-MESSAGE-METHOD--CAPS"><primary sortas="SOUP_MESSAGE_METHOD">SOUP_MESSAGE_METHOD</primary></indexterm><programlisting>#define SOUP_MESSAGE_METHOD        "method"
</programlisting>
<para>
Alias for the <link linkend="SoupMessage--method"><type>"method"</type></link> property. (The message's
HTTP method.)</para>
<para>
</para></refsect2>
<refsect2 id="SOUP-MESSAGE-URI--CAPS" role="macro">
<title>SOUP_MESSAGE_URI</title>
<indexterm zone="SOUP-MESSAGE-URI--CAPS"><primary sortas="SOUP_MESSAGE_URI">SOUP_MESSAGE_URI</primary></indexterm><programlisting>#define SOUP_MESSAGE_URI           "uri"
</programlisting>
<para>
Alias for the <link linkend="SoupMessage--uri"><type>"uri"</type></link> property. (The message's
<link linkend="SoupURI"><type>SoupURI</type></link>.)</para>
<para>
</para></refsect2>
<refsect2 id="SOUP-MESSAGE-HTTP-VERSION--CAPS" role="macro">
<title>SOUP_MESSAGE_HTTP_VERSION</title>
<indexterm zone="SOUP-MESSAGE-HTTP-VERSION--CAPS"><primary sortas="SOUP_MESSAGE_HTTP_VERSION">SOUP_MESSAGE_HTTP_VERSION</primary></indexterm><programlisting>#define SOUP_MESSAGE_HTTP_VERSION  "http-version"
</programlisting>
<para>
Alias for the <link linkend="SoupMessage--http-version"><type>"http-version"</type></link> property. (The
message's <link linkend="SoupHTTPVersion"><type>SoupHTTPVersion</type></link>.)</para>
<para>
</para></refsect2>
<refsect2 id="SOUP-MESSAGE-FLAGS--CAPS" role="macro">
<title>SOUP_MESSAGE_FLAGS</title>
<indexterm zone="SOUP-MESSAGE-FLAGS--CAPS"><primary sortas="SOUP_MESSAGE_FLAGS">SOUP_MESSAGE_FLAGS</primary></indexterm><programlisting>#define SOUP_MESSAGE_FLAGS         "flags"
</programlisting>
<para>
Alias for the <link linkend="SoupMessage--flags"><type>"flags"</type></link> property. (The message's
<link linkend="SoupMessageFlags"><type>SoupMessageFlags</type></link>.)</para>
<para>
</para></refsect2>
<refsect2 id="SOUP-MESSAGE-STATUS-CODE--CAPS" role="macro">
<title>SOUP_MESSAGE_STATUS_CODE</title>
<indexterm zone="SOUP-MESSAGE-STATUS-CODE--CAPS"><primary sortas="SOUP_MESSAGE_STATUS_CODE">SOUP_MESSAGE_STATUS_CODE</primary></indexterm><programlisting>#define SOUP_MESSAGE_STATUS_CODE   "status-code"
</programlisting>
<para>
Alias for the <link linkend="SoupMessage--status-code"><type>"status-code"</type></link> property. (The
message's HTTP response status code.)</para>
<para>
</para></refsect2>
<refsect2 id="SOUP-MESSAGE-REASON-PHRASE--CAPS" role="macro">
<title>SOUP_MESSAGE_REASON_PHRASE</title>
<indexterm zone="SOUP-MESSAGE-REASON-PHRASE--CAPS"><primary sortas="SOUP_MESSAGE_REASON_PHRASE">SOUP_MESSAGE_REASON_PHRASE</primary></indexterm><programlisting>#define SOUP_MESSAGE_REASON_PHRASE "reason-phrase"
</programlisting>
<para>
Alias for the <link linkend="SoupMessage--reason-phrase"><type>"reason-phrase"</type></link> property. (The
message's HTTP response reason phrase.)</para>
<para>
</para></refsect2>
<refsect2 id="SOUP-MESSAGE-SERVER-SIDE--CAPS" role="macro">
<title>SOUP_MESSAGE_SERVER_SIDE</title>
<indexterm zone="SOUP-MESSAGE-SERVER-SIDE--CAPS"><primary sortas="SOUP_MESSAGE_SERVER_SIDE">SOUP_MESSAGE_SERVER_SIDE</primary></indexterm><programlisting>#define SOUP_MESSAGE_SERVER_SIDE   "server-side"
</programlisting>
<para>
Alias for the <link linkend="SoupMessage--server-side"><type>"server-side"</type></link> property. (<link linkend="TRUE--CAPS"><literal>TRUE</literal></link> if
the message was created by <link linkend="SoupServer"><type>SoupServer</type></link>.)</para>
<para>
</para></refsect2>

</refsect1>
<refsect1 id="SoupMessage.property-details" role="property_details">
<title role="property_details.title">Property Details</title>
<refsect2 id="SoupMessage--flags" role="property"><title>The <literal>&quot;flags&quot;</literal> property</title>
<indexterm zone="SoupMessage--flags"><primary sortas="SoupMessage:flags">SoupMessage:flags</primary></indexterm><programlisting>  &quot;flags&quot;                    <link linkend="SoupMessageFlags">SoupMessageFlags</link>      : Read / Write</programlisting>
<para>Various message options.</para></refsect2>
<refsect2 id="SoupMessage--http-version" role="property"><title>The <literal>&quot;http-version&quot;</literal> property</title>
<indexterm zone="SoupMessage--http-version"><primary sortas="SoupMessage:http-version">SoupMessage:http-version</primary></indexterm><programlisting>  &quot;http-version&quot;             <link linkend="SoupHTTPVersion">SoupHTTPVersion</link>       : Read / Write</programlisting>
<para>The HTTP protocol version to use.</para><para>Default value: SOUP_HTTP_1_1</para>
</refsect2>
<refsect2 id="SoupMessage--method" role="property"><title>The <literal>&quot;method&quot;</literal> property</title>
<indexterm zone="SoupMessage--method"><primary sortas="SoupMessage:method">SoupMessage:method</primary></indexterm><programlisting>  &quot;method&quot;                   <link linkend="gchar">gchar</link>*                : Read / Write</programlisting>
<para>The message's HTTP method.</para><para>Default value: "GET"</para>
</refsect2>
<refsect2 id="SoupMessage--reason-phrase" role="property"><title>The <literal>&quot;reason-phrase&quot;</literal> property</title>
<indexterm zone="SoupMessage--reason-phrase"><primary sortas="SoupMessage:reason-phrase">SoupMessage:reason-phrase</primary></indexterm><programlisting>  &quot;reason-phrase&quot;            <link linkend="gchar">gchar</link>*                : Read / Write</programlisting>
<para>The HTTP response reason phrase.</para><para>Default value: NULL</para>
</refsect2>
<refsect2 id="SoupMessage--server-side" role="property"><title>The <literal>&quot;server-side&quot;</literal> property</title>
<indexterm zone="SoupMessage--server-side"><primary sortas="SoupMessage:server-side">SoupMessage:server-side</primary></indexterm><programlisting>  &quot;server-side&quot;              <link linkend="gboolean">gboolean</link>              : Read / Write / Construct Only</programlisting>
<para>Whether or not the message is server-side rather than client-side.</para><para>Default value: FALSE</para>
</refsect2>
<refsect2 id="SoupMessage--status-code" role="property"><title>The <literal>&quot;status-code&quot;</literal> property</title>
<indexterm zone="SoupMessage--status-code"><primary sortas="SoupMessage:status-code">SoupMessage:status-code</primary></indexterm><programlisting>  &quot;status-code&quot;              <link linkend="guint">guint</link>                 : Read / Write</programlisting>
<para>The HTTP response status code.</para><para>Allowed values: &lt;= 599</para>
<para>Default value: 0</para>
</refsect2>
<refsect2 id="SoupMessage--uri" role="property"><title>The <literal>&quot;uri&quot;</literal> property</title>
<indexterm zone="SoupMessage--uri"><primary sortas="SoupMessage:uri">SoupMessage:uri</primary></indexterm><programlisting>  &quot;uri&quot;                      <link linkend="SoupURI">SoupURI</link>*              : Read / Write</programlisting>
<para>The message's Request-URI.</para></refsect2>
</refsect1>

<refsect1 id="SoupMessage.signal-details" role="signals">
<title role="signals.title">Signal Details</title>
<refsect2 id="SoupMessage-finished" role="signal"><title>The <literal>&quot;finished&quot;</literal> signal</title>
<indexterm zone="SoupMessage-finished"><primary sortas="SoupMessage::finished">SoupMessage::finished</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted when all HTTP processing is finished for a message.
(After <link linkend="SoupMessage-got-body"><type>"got_body"</type></link> for client-side messages, or
after <link linkend="SoupMessage-wrote-body"><type>"wrote_body"</type></link> for server-side messages.)</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2 id="SoupMessage-got-body" role="signal"><title>The <literal>&quot;got-body&quot;</literal> signal</title>
<indexterm zone="SoupMessage-got-body"><primary sortas="SoupMessage::got-body">SoupMessage::got-body</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted after receiving the complete message body. (For a
server-side message, this means it has received the request
body. For a client-side message, this means it has received
the response body and is nearly done with the message.)
</para>
<para>
See also <link linkend="soup-message-add-header-handler"><function>soup_message_add_header_handler()</function></link> and
<link linkend="soup-message-add-status-code-handler"><function>soup_message_add_status_code_handler()</function></link>, which can be used
to connect to a subset of emissions of this signal.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2 id="SoupMessage-got-chunk" role="signal"><title>The <literal>&quot;got-chunk&quot;</literal> signal</title>
<indexterm zone="SoupMessage-got-chunk"><primary sortas="SoupMessage::got-chunk">SoupMessage::got-chunk</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="SoupBuffer">SoupBuffer</link>  *chunk,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted after receiving a chunk of a message body. Note
that "chunk" in this context means any subpiece of the
body, not necessarily the specific HTTP 1.1 chunks sent by
the other side.
</para>
<para>
If you cancel or requeue <parameter>msg</parameter> while processing this signal,
then the current HTTP I/O will be stopped after this signal
emission finished, and <parameter>msg</parameter>'s connection will be closed.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>chunk</parameter>&#160;:</term>
<listitem><simpara> the just-read chunk
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2 id="SoupMessage-got-headers" role="signal"><title>The <literal>&quot;got-headers&quot;</literal> signal</title>
<indexterm zone="SoupMessage-got-headers"><primary sortas="SoupMessage::got-headers">SoupMessage::got-headers</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted after receiving all message headers for a message.
(For a client-side message, this is after receiving the
Status-Line and response headers; for a server-side
message, it is after receiving the Request-Line and request
headers.)
</para>
<para>
See also <link linkend="soup-message-add-header-handler"><function>soup_message_add_header_handler()</function></link> and
<link linkend="soup-message-add-status-code-handler"><function>soup_message_add_status_code_handler()</function></link>, which can be used
to connect to a subset of emissions of this signal.
</para>
<para>
If you cancel or requeue <parameter>msg</parameter> while processing this signal,
then the current HTTP I/O will be stopped after this signal
emission finished, and <parameter>msg</parameter>'s connection will be closed.
(If you need to requeue a message--eg, after handling
authentication or redirection--it is usually better to
requeue it from a <link linkend="SoupMessage-got-body"><type>"got_body"</type></link> handler rather
than a <link linkend="SoupMessage-got-header"><type>"got_header"</type></link> handler, so that the
existing HTTP connection can be reused.)</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2 id="SoupMessage-got-informational" role="signal"><title>The <literal>&quot;got-informational&quot;</literal> signal</title>
<indexterm zone="SoupMessage-got-informational"><primary sortas="SoupMessage::got-informational">SoupMessage::got-informational</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted after receiving a 1xx (Informational) response for
a (client-side) message. The response_headers will be
filled in with the headers associated with the
informational response; however, those header values will
be erased after this signal is done.
</para>
<para>
If you cancel or requeue <parameter>msg</parameter> while processing this signal,
then the current HTTP I/O will be stopped after this signal
emission finished, and <parameter>msg</parameter>'s connection will be closed.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2 id="SoupMessage-restarted" role="signal"><title>The <literal>&quot;restarted&quot;</literal> signal</title>
<indexterm zone="SoupMessage-restarted"><primary sortas="SoupMessage::restarted">SoupMessage::restarted</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted when a request that was already sent once is now
being sent again (eg, because the first attempt received a
redirection response, or because we needed to use
authentication).</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2 id="SoupMessage-wrote-body" role="signal"><title>The <literal>&quot;wrote-body&quot;</literal> signal</title>
<indexterm zone="SoupMessage-wrote-body"><primary sortas="SoupMessage::wrote-body">SoupMessage::wrote-body</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted immediately after writing the complete body for a
message. (For a client-side message, this means that
libsoup is done writing and is now waiting for the response
from the server. For a server-side message, this means that
libsoup has finished writing the response and is nearly
done with the message.)</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2 id="SoupMessage-wrote-body-data" role="signal"><title>The <literal>&quot;wrote-body-data&quot;</literal> signal</title>
<indexterm zone="SoupMessage-wrote-body-data" role="2.4.1"><primary sortas="SoupMessage::wrote-body-data">SoupMessage::wrote-body-data</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="SoupBuffer">SoupBuffer</link>  *chunk,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted immediately after writing a portion of the message
body to the network.
</para>
<para>
Unlike <link linkend="SoupMessage-wrote-chunk"><type>"wrote_chunk"</type></link>, this is emitted after
every successful <link linkend="write"><function>write()</function></link> call, not only after finishing a
complete "chunk".</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>chunk</parameter>&#160;:</term>
<listitem><simpara> the data written
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist><para>Since 2.4.1</para></refsect2><refsect2 id="SoupMessage-wrote-chunk" role="signal"><title>The <literal>&quot;wrote-chunk&quot;</literal> signal</title>
<indexterm zone="SoupMessage-wrote-chunk"><primary sortas="SoupMessage::wrote-chunk">SoupMessage::wrote-chunk</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted immediately after writing a body chunk for a message.
</para>
<para>
Note that this signal is not parallel to
<link linkend="SoupMessage-got-chunk"><type>"got_chunk"</type></link>; it is emitted only when a complete
chunk (added with <link linkend="soup-message-body-append"><function>soup_message_body_append()</function></link> or
<link linkend="soup-message-body-append-buffer"><function>soup_message_body_append_buffer()</function></link>) has been written. To get
more useful continuous progress information, use
<link linkend="SoupMessage-wrote-body-data"><type>"wrote_body_data"</type></link>.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2 id="SoupMessage-wrote-headers" role="signal"><title>The <literal>&quot;wrote-headers&quot;</literal> signal</title>
<indexterm zone="SoupMessage-wrote-headers"><primary sortas="SoupMessage::wrote-headers">SoupMessage::wrote-headers</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted immediately after writing the headers for a
message. (For a client-side message, this is after writing
the request headers; for a server-side message, it is after
writing the response headers.)</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2 id="SoupMessage-wrote-informational" role="signal"><title>The <literal>&quot;wrote-informational&quot;</literal> signal</title>
<indexterm zone="SoupMessage-wrote-informational"><primary sortas="SoupMessage::wrote-informational">SoupMessage::wrote-informational</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted immediately after writing a 1xx (Informational)
response for a (server-side) message.</para>
<para>
</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&#160;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&#160;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2>
</refsect1>


<refsect1 id="SoupMessage.see-also">
<title>See Also</title>
#SoupMessageHeaders, <link linkend="SoupMessageBody"><type>SoupMessageBody</type></link>
</refsect1>

</refentry>
